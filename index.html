<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Grey — Light NieR UI (stable)</title>
<meta name="theme-color" content="#EEE8DC" />
<style>
/* =========================
   Light parchment palette (NieR-like, monotone)
   ========================= */
:root{
  --bg:#EEE8DC; --bg-grad:#F6F1E7;
  --ink:#222426; --muted:#64696E; --accent:#8A8174;

  --panel:#FFFFFF; --panel-2:#FAF7F0;
  --line:#D8D2C6; --line-soft:#E7E0D4;

  --slot:#FAF7F0; --fade:#EEE8DC;
  --card:#FFFFFF; --card-line:#DAD3C8;

  --card-w:120px; --card-h:172px; --card-radius:12px;

  --shadow-soft:0 2px 10px rgba(60,52,44,.12);
  --shadow-panel:0 1px 6px rgba(60,52,44,.08) inset, 0 1px 10px rgba(60,52,44,.05);
}
*{box-sizing:border-box;margin:0;padding:0}
html,body{min-height:100%}
body{
  background: radial-gradient(1200px 700px at 50% -260px, rgba(90,78,65,.06), transparent 60%), var(--bg-grad);
  color:var(--ink);
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
  -webkit-font-smoothing:antialiased;
  overflow-x:hidden;
}

/* ===== HUD (values + single row, never covers board) ===== */
.hud{
  position:sticky; top:0; z-index:70;
  display:flex; align-items:center; justify-content:space-between; gap:12px;
  padding:calc(6px + env(safe-area-inset-top, 0)) 12px 6px 12px;
  background:linear-gradient(180deg,#fff,var(--panel-2));
  border-bottom:1px solid var(--line);
}
.hud__side{display:flex; align-items:center; gap:10px}
.stat{
  display:inline-flex; align-items:center; gap:6px;
  padding:6px 8px; border-radius:10px; background:#fff; border:1px solid var(--line);
  color:#6b6258; font-weight:700; letter-spacing:.02em;
  box-shadow:var(--shadow-soft)
}
.stat svg{width:18px;height:18px;stroke:#6f6a60}
.stat__label{opacity:.8}
.stat__value{min-width:2ch;text-align:right}

/* reserve space under sticky HUD so content never sits behind it */
.wrap{padding:14px; max-width:1100px; margin:auto; padding-bottom:170px; padding-top:var(--hud-h,56px)}

/* ===== Toast ===== */
.topLog{
  position:fixed; top:10px; left:50%; transform:translateX(-50%);
  background:#fff; border:1px solid var(--line); color:#2b2f33; border-radius:12px;
  padding:9px 12px; box-shadow:0 8px 18px rgba(60,52,44,.18); z-index:80; display:none;
  max-width:92vw; font-size:12px; letter-spacing:.01em;
}
.topLog.show{display:block}

/* ===== Layout containers ===== */
.zone{
  background:linear-gradient(180deg,#fff,var(--panel-2));
  border:1px solid var(--line); border-radius:14px; padding:12px; margin:12px 0;
  box-shadow:var(--shadow-panel)
}
.title{font-weight:700;color:var(--accent);margin-bottom:8px}

/* ===== Boards ===== */
.slots{display:flex;gap:10px;flex-wrap:wrap}
.slot{
  flex:1 0 30%; background:var(--slot); border:2px dashed #CEC7BA; border-radius:12px;
  padding:10px; min-height:146px; position:relative
}
.slot h5{font-size:12px;color:#6a6f76;margin-bottom:6px}
.pips{display:flex;gap:4px;margin-top:6px}
.pip{width:10px;height:10px;border-radius:999px;border:1px solid #BBB3A6;background:#EFE9DC}
.pip.on{background:#7A838C;border-color:#7A838C}

/* ===== Glyphs ===== */
.glyphTray{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 8px}
.glyphTok{
  position:relative;display:inline-flex;align-items:center;justify-content:center;
  min-width:46px;height:28px;border-radius:8px;background:#fff;border:1px solid var(--line);
  color:#3a3d40;font-size:11px;box-shadow:var(--shadow-soft);padding:0 8px
}
.glyphTok::before{content:'✦';opacity:.95;font-size:12px;color:var(--accent)}
.glyphTok.own{cursor:pointer}
.glyphPeek{
  position:absolute;left:50%;bottom:110%;transform:translateX(-50%);
  background:#fff;border:1px solid var(--line);color:#222;
  padding:6px 8px;border-radius:10px;font-size:11px;white-space:nowrap;box-shadow:0 10px 22px rgba(60,50,40,.18);display:none
}
.glyphTok.own:hover .glyphPeek,.glyphTok.own:focus .glyphPeek{display:block}

/* ===== Aetherflow (aligned) ===== */
.flowWrap{overflow-x:auto;scrollbar-width:none;mask-image:linear-gradient(90deg,transparent 0,var(--fade) 24px,#fff calc(100% - 24px),transparent 100%)}
.flowWrap::-webkit-scrollbar{display:none}
.flowGrid{display:grid;grid-template-columns:repeat(5,1fr);gap:12px;min-width:820px}
.costCell{display:flex;justify-content:center}
.costChip{min-width:42px;text-align:center;font-weight:800;letter-spacing:.04em;padding:4px 8px;border:1px solid var(--line);border-radius:999px;background:#fff;color:var(--accent);font-size:12px}
.marketCard{
  background:var(--card);border:1px solid var(--card-line);border-radius:14px;padding:10px;min-height:150px;position:relative;
  box-shadow:0 4px 14px rgba(60,52,44,.12)
}
.marketCard h4{font-size:14px;color:var(--accent);margin-bottom:6px}
.marketCard p{font-size:12px;color:var(--muted);margin:6px 0 8px}
.marketCard .actions{display:flex;gap:8px}
.marketCard .actions button{
  padding:7px 12px;border-radius:10px;border:1px solid var(--line);background:#fff;color:var(--ink)
}
.marketBadge{
  position:absolute;top:8px;right:10px;border:1px solid var(--line);background:#fff;color:#555048;
  padding:2px 6px;border-radius:8px;font-size:11px
}
.cardArt{
  height:128px;border-radius:10px;overflow:hidden;border:1px solid var(--line);background:#fff;
  display:grid;place-items:center
}
.cardArt img{width:100%;height:100%;object-fit:contain;object-position:center}

/* ===== Hand ribbon (lock to X, no vertical roving) ===== */
.ribbon-wrap{
  position:fixed;left:0;right:0;bottom:0;z-index:40;
  padding:10px 8px calc(12px + env(safe-area-inset-bottom)); 
  background:linear-gradient(0deg,#F2ECE1,#F8F3EA); border-top:1px solid var(--line)
}
.ribbon{
  display:flex; gap:6px; height:118px; 
  overflow-x:auto; overflow-y:hidden; scrollbar-width:none;
  touch-action:pan-x; overscroll-behavior-y:contain;
  align-items:flex-start;
}
.ribbon::-webkit-scrollbar{display:none}
.rCard{
  width:var(--card-w); height:var(--card-h);
  border-radius:var(--card-radius); overflow:hidden; background:#fff; border:1px solid var(--card-line);
  box-shadow:0 6px 14px rgba(60,52,44,.18);
  display:flex; flex-direction:column; user-select:none; -webkit-user-drag:none; touch-action:none;
}
.rHead{padding:7px 9px 6px;font-size:11px;font-weight:800;letter-spacing:.02em;background:linear-gradient(180deg,#ffffff,#F4EEE3);border-bottom:1px solid var(--line);color:#8A8174;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.rArt{height:98px;display:grid;place-items:center;background:#fff;position:relative}
.rArt img{width:100%;height:100%;object-fit:contain;object-position:center}
.rFoot{padding:6px 8px 7px;font-size:11px;color:#656b70;border-top:1px solid var(--line);background:#fcfaf6;line-height:1.25}

/* badges (cost/aether pips) */
.badgeTL,.badgeTR{position:absolute;top:6px;padding:2px 6px;border-radius:8px;font-size:10px;font-weight:700;background:#fff;border:1px solid var(--line);color:#4a4e52}
.badgeTL{left:6px}.badgeTR{right:6px}

/* ===== Inspect modal ===== */
.inspectBack{position:fixed;inset:0;z-index:75;background:rgba(20,20,20,.25);display:none;align-items:flex-end;justify-content:center;padding-bottom:140px}
.inspectBack.show{display:flex}
.inspectCard{min-width:min(580px,92vw);max-width:92vw;background:#fff;border:1px solid var(--line);border-radius:14px;box-shadow:0 14px 32px rgba(60,52,44,.22);padding:12px 14px}
.inspectCard h3{margin:0 0 6px;font-size:16px;font-weight:800;color:#8A8174}
.inspectCard p{margin:0 0 8px;font-size:13px;color:#2b2f33}
.inspectCard .artBox{height:190px;border-radius:10px;overflow:hidden;margin:6px 0 10px;border:1px solid var(--line);background:#fff;display:grid;place-items:center}
.inspectCard .artBox img{width:100%;height:100%;object-fit:contain;object-position:center}
.inspectActions{display:flex;gap:8px;justify-content:flex-end}
.inspectActions button{padding:8px 12px;border-radius:10px;border:1px solid var(--line);background:#fff;color:#1f2225}

/* ===== Deck / Discard + FAB ===== */
.deckBar{position:fixed;left:12px;bottom:126px;z-index:50;display:flex;gap:10px}
.chipCirc{
  width:42px;height:42px;border-radius:999px;display:grid;place-items:center;
  background:#fff;border:1px solid var(--line);box-shadow:var(--shadow-soft);position:relative
}
.chipCirc svg{width:18px;height:18px;stroke:#6F6A60}
.chipCirc small{
  position:absolute;bottom:-10px;background:#fff;border:1px solid var(--line);border-radius:10px;padding:1px 6px;font-size:10px;color:#3a3d40
}
.fabDial{position:fixed;right:12px;bottom:126px;z-index:50;display:flex;flex-direction:column;gap:12px}
.fab{width:46px;height:46px;border-radius:999px;background:#fff;border:1px solid var(--line);display:grid;place-items:center;color:#1d1f21;font-size:18px;box-shadow:var(--shadow-soft)}
/* slot highlight on drag */
#playerSlots .slot.is-hot{outline:2px solid var(--accent);outline-offset:2px}
</style>
</head>
<body>

<!-- HUD (single row with values; replaces stacked icons) -->
<header class="hud" id="hud">
  <div class="hud__side" id="hudLeft">
    <div class="stat" aria-label="Your Health">
      <svg viewBox="0 0 24 24" fill="none"><path d="M12 21s-7-4.5-7-9a4 4 0 0 1 7-2 4 4 0 0 1 7 2c0 4.5-7 9-7 9Z"/></svg>
      <span class="stat__label">HP</span><span class="stat__value" id="hpValue">0</span>
    </div>
    <div class="stat" aria-label="Your Aether">
      <svg viewBox="0 0 24 24" fill="none"><path d="M14 3 4 15h6l-2 6 12-14h-6z"/></svg>
      <span class="stat__label">Æ</span><span class="stat__value" id="aeValue">0</span>
    </div>
  </div>
  <div class="hud__side" id="hudRight">
    <div class="stat" aria-label="AI Aether">
      <svg viewBox="0 0 24 24" fill="none"><path d="M14 3 4 15h6l-2 6 12-14h-6z"/></svg>
      <span class="stat__label">AI Æ</span><span class="stat__value" id="aiAeValue">0</span>
    </div>
    <div class="stat" aria-label="AI Health">
      <svg viewBox="0 0 24 24" fill="none"><path d="M12 21s-7-4.5-7-9a4 4 0 0 1 7-2 4 4 0 0 1 7 2c0 4.5-7 9-7 9Z"/></svg>
      <span class="stat__label">AI HP</span><span class="stat__value" id="aiHpValue">0</span>
    </div>
  </div>
</header>

<!-- Toast -->
<div id="topLog" class="topLog" aria-live="polite"></div>

<div class="wrap">
  <!-- AI Board -->
  <div class="zone" id="aiBoard">
    <div class="title">AI Board</div>
    <div class="slots" id="aiSlots"></div>
  </div>

  <!-- Aetherflow -->
  <div class="zone">
    <div class="title" style="text-align:center">Aetherflow</div>
    <div class="flowWrap">
      <div class="flowGrid">
        <div class="costCell"><div class="costChip">4</div></div>
        <div class="costCell"><div class="costChip">3</div></div>
        <div class="costCell"><div class="costChip">2</div></div>
        <div class="costCell"><div class="costChip">2</div></div>
        <div class="costCell"><div class="costChip">2</div></div>

        <div class="marketCard" data-flow="0"></div>
        <div class="marketCard" data-flow="1"></div>
        <div class="marketCard" data-flow="2"></div>
        <div class="marketCard" data-flow="3"></div>
        <div class="marketCard" data-flow="4"></div>
      </div>
    </div>
  </div>

  <!-- Player Board -->
  <div class="zone">
    <div class="title">Your Board</div>
    <div class="glyphTray" id="glyphTray"></div>
    <div class="slots" id="playerSlots"></div>
  </div>
</div>

<!-- Deck / Discard + FAB -->
<div class="deckBar">
  <button class="chipCirc" id="chipDeck" title="Deck" aria-label="Deck">
    <svg viewBox="0 0 24 24" fill="none"><rect x="5" y="4" width="14" height="16" rx="2"/><path d="M8 8h8"/></svg>
    <small id="deckCount">0</small>
  </button>
  <button class="chipCirc" id="chipDiscard" title="Discard" aria-label="Discard">
    <svg viewBox="0 0 24 24" fill="none"><rect x="3" y="14" width="18" height="6" rx="2"/><path d="M7 10h10M9 7h6"/></svg>
    <small id="discardCount">0</small>
  </button>
</div>
<div class="fabDial">
  <button id="fabDraw"  class="fab" title="Draw" aria-label="Draw">⇧</button>
  <button id="fabEnd"   class="fab" title="End Turn" aria-label="End Turn">⏵</button>
  <button id="fabReset" class="fab" title="Reset" aria-label="Reset">↺</button>
</div>

<!-- Hand ribbon -->
<section class="ribbon-wrap"><div class="ribbon" id="ribbon"></div></section>

<!-- Inspect -->
<div id="inspect" class="inspectBack" role="dialog" aria-modal="true">
  <div class="inspectCard">
    <h3 id="insTitle">Card</h3>
    <div class="artBox"><img id="insArt" alt="" loading="lazy"></div>
    <p id="insText"></p>
    <div class="inspectActions">
      <button id="btnInspectPlay">Play/Set</button>
      <button id="btnInspectChan">Channel</button>
      <button id="btnInspectClose" aria-label="Close">Close</button>
    </div>
  </div>
</div>

<script>
/* =========================
   Constants (single source of truth)
   ========================= */
const HAND_DRAW=5;
const FLOW_PRICES=[4,3,2,2,2];

/* =========================
   Card Data
   ========================= */
const STARTER=[
  {n:'Apprentice Bolt',t:'Spell',txt:'Deal 1.',p:1,artKey:'apprentice-bolt'},
  {n:'Apprentice Bolt',t:'Spell',txt:'Deal 1.',p:1,artKey:'apprentice-bolt'},
  {n:'Apprentice Bolt',t:'Spell',txt:'Deal 1.',p:1,artKey:'apprentice-bolt'},
  {n:'Kindle',t:'Spell',txt:'On resolve: +1⚡.',p:2,eff:'gain1',artKey:'kindle'},
  {n:'Glacial Ward',t:'Glyph',txt:'Prevent 1 next hit.',eff:'g_barrier',artKey:'glacial-ward'},
  {n:'Mirror Ward',t:'Glyph',txt:'Reflect next damage (sim).',eff:'g_mirror',artKey:'mirror-ward'},
  {n:'Ward Sigil',t:'Glyph',txt:'Prevent 1 (sim).',eff:'g_barrier',artKey:'ward-sigil'},
  {n:'Meditate',t:'Instant',txt:'↺ +1⚡ (or play +1⚡).',v:1,artKey:'meditate'}
];
const ECON_CARDS=[
  {n:'Aether Pebble',t:'Instant',txt:'↺ +1⚡ (or play +1⚡).',v:1,artKey:'aether-pebble'},
  {n:'Aether Shard',t:'Instant',txt:'↺ +2⚡ (or play +2⚡).',v:2,artKey:'aether-shard'},
  {n:'Aether Core',t:'Instant',txt:'↺ +3⚡ (or play +3⚡).',v:3,artKey:'aether-core'}
];
const OFFENSE_CARDS=[
  {n:'Spark Javelin',t:'Spell',txt:'Deal 2.',p:1,v:1,artKey:'spark-javelin'},
  {n:'Flame Lash',t:'Spell',txt:'Deal 2 then 3.',p:2,v:0,artKey:'flame-lash'},
  {n:'Ember',t:'Spell',txt:'Deal 2.',p:1,v:0,artKey:'ember'},
  {n:'Frost Bolt',t:'Spell',txt:'Deal 1; slow next hit (sim).',p:2,v:0,artKey:'frost-bolt'},
  {n:'Siphon Hex',t:'Spell',txt:'Drain 1⚡ from foe.',p:2,v:1,eff:'drain1',artKey:'siphon-hex'},
  {n:'Stonewall',t:'Spell',txt:'+1 advance tax (foe).',p:2,v:0,eff:'tax',artKey:'stonewall'}
];
const FLOW_POOL=[...ECON_CARDS,...OFFENSE_CARDS];

/* =========================
   Procedural SVG art (centered, monotone-friendly)
   ========================= */
function artSVG({motif='aether'}={}) {
  const gold='#8A8174', bone='#5C5F63';
  const fx={
    fire:`<path d="M150 190c-18-38 12-64 26-90-4 30 18 46 8 78 34-14 48-48 44-92 36 38 32 86-22 122-22 16-44 24-56 26z" fill="${gold}" opacity=".85"/>`,
    lightning:`<path d="M160 120l-48 72h36l-40 60 88-98h-34l30-34z" fill="${bone}" opacity=".9"/>`,
    ice:`<g fill="${bone}" opacity=".85"><path d="M180 120l16 40 40 16-40 16-16 40-16-40-40-16 40-16z"/></g>`,
    aether:`<circle cx="200" cy="180" r="34" fill="none" stroke="${gold}" stroke-width="4" opacity=".9"/>`,
    ward:`<g stroke="${gold}" stroke-width="3" opacity=".9" fill="none"><circle cx="200" cy="180" r="40"/><path d="M200 140l24 40h-48z"/><circle cx="200" cy="180" r="8" stroke-width="2"/></g>`,
    hex:`<g fill="none" stroke="${bone}" opacity=".9"><path d="M164 160h72v40h-72z" stroke-width="3"/><path d="M164 180h72" stroke-width="6" opacity=".4"/></g>`,
    stone:`<g fill="${gold}" opacity=".28"><rect x="172" y="156" width="20" height="32"/><rect x="196" y="148" width="24" height="40"/><rect x="224" y="164" width="18" height="24"/></g>`,
    meditate:`<g fill="none" stroke="${gold}" stroke-width="3" opacity=".9"><circle cx="200" cy="180" r="28"/><circle cx="200" cy="180" r="44" opacity=".45"/></g>`
  }[motif]||'';
  return 'data:image/svg+xml;utf8,'+encodeURIComponent(`
  <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 420'>
    <defs>
      <filter id='g'><feTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='2'/><feComponentTransfer><feFuncA type='table' tableValues='0 .08'/></feComponentTransfer></filter>
      <linearGradient id='v' x1='0' x2='0' y1='0' y2='1'><stop offset='0' stop-color='#ffffff'/><stop offset='1' stop-color='#F7F2E9'/></linearGradient>
    </defs>
    <rect width='100%' height='100%' fill='url(#v)'/>
    <rect width='100%' height='100%' filter='url(#g)' opacity='.12'/>
    <g transform='translate(-40 0)'>${fx}</g>
  </svg>`);
}
const ART_MAP={
  'flame-lash':artSVG({motif:'fire'}),'spark-javelin':artSVG({motif:'lightning'}),
  'frost-bolt':artSVG({motif:'ice'}),'ember':artSVG({motif:'fire'}),
  'siphon-hex':artSVG({motif:'hex'}),'stonewall':artSVG({motif:'stone'}),
  'aether-core':artSVG({motif:'aether'}),'aether-shard':artSVG({motif:'aether'}),
  'aether-pebble':artSVG({motif:'aether'}),'meditate':artSVG({motif:'meditate'}),
  'glacial-ward':artSVG({motif:'ward'}),'mirror-ward':artSVG({motif:'ward'}),
  'ward-sigil':artSVG({motif:'ward'}),'apprentice-bolt':artSVG({motif:'lightning'}),
  'kindle':artSVG({motif:'fire'})
};
const slug=s=>(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
function resolveArt(c){const k=(c&&(c.artKey||slug(c.n)))||'card';return ART_MAP[k]||ART_MAP['aether-core'];}

/* =========================
   DOM helpers
   ========================= */
function $(s,r=document){return r.querySelector(s)}
const topLog=$('#topLog');
const playerSlots=$('#playerSlots'), aiSlots=$('#aiSlots'), glyphTray=$('#glyphTray');
const rRibbon=$('#ribbon');
const inspect=$('#inspect'), insTitle=$('#insTitle'), insText=$('#insText'), insArt=$('#insArt');
const marketCells=[...document.querySelectorAll('[data-flow]')];
const fabDraw=$('#fabDraw'), fabEnd=$('#fabEnd'), fabReset=$('#fabReset');
const deckCount=$('#deckCount'), discardCount=$('#discardCount');

const hpValue=$('#hpValue'), aeValue=$('#aeValue'), aiHpValue=$('#aiHpValue'), aiAeValue=$('#aiAeValue');

let S={}, turnLog=[], hideTimer, inspectIndex=-1;

function shuf(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
function uid(){return Math.random().toString(36).slice(2,9)}
function makeStarterDeck(){return shuf(STARTER.map(x=>({...x,id:uid()})))}
function makeFlowDeck(){return shuf(FLOW_POOL.map(x=>({...x,id:uid()})))}
function log(m){turnLog.push(m); topLog.innerHTML=turnLog.slice(-3).map(x=>`<div>${x}</div>`).join(''); topLog.classList.add('show'); clearTimeout(hideTimer); hideTimer=setTimeout(()=>topLog.classList.remove('show'),2200)}
function logResetTurn(){turnLog=[]; topLog.classList.remove('show')}

/* =========================
   Game + AI
   ========================= */
function initGame(){
  S={hp:5,ae:0,deck:makeStarterDeck(),hand:[],disc:[],slots:[null,null,null],glyphs:[],
     ai:{hp:5,ae:0,deck:makeStarterDeck(),hand:[],disc:[],slots:[null,null,null],glyphs:[]},
     flowDeck:makeFlowDeck(),flowRow:[null,null,null,null,null],turn:1};
  ensureMarket(true); startTurn(true);
}
function startTurn(first=false){ if(!first) S.turn++; logResetTurn(); while(S.hand.length<HAND_DRAW) drawCard(); render(); log(`Turn ${S.turn} — drew to ${HAND_DRAW}.`); }
function endTurn(){ S.slots.forEach(s=>{ if(s) s.advUsed=false; }); slideFlow(); if(S.hand.length){ S.disc.push(...S.hand); S.hand.length=0; log("End Turn: auto-discard hand."); } render(); setTimeout(()=>aiTurn(),300); setTimeout(()=>startTurn(false),800); }
function drawCard(){ if(S.deck.length===0){ if(S.disc.length===0){ log("No cards to draw."); return; } S.deck=shuf(S.disc); S.disc=[]; log("You reshuffle."); } S.hand.push(S.deck.pop()); }

/* =========================
   Render
   ========================= */
function pips(cur,total){let h='';for(let i=1;i<=total;i++)h+=`<span class="pip ${i<=cur?'on':''}"></span>`;return h;}
function render(){
  deckCount.textContent=S.deck.length; discardCount.textContent=S.disc.length;

  // HUD numbers
  hpValue.textContent=S.hp; aeValue.textContent=S.ae;
  aiHpValue.textContent=S.ai.hp; aiAeValue.textContent=S.ai.ae||0;

  // Player board
  playerSlots.innerHTML='';
  S.slots.forEach((s,i)=>{
    const d=document.createElement('div'); d.className='slot'; d.innerHTML=`<h5>Slot ${i+1}</h5>`;
    if(s){
      d.innerHTML+=`<div class="marketCard" style="min-width:auto;max-width:none;margin-bottom:8px">
        <h4>${s.c.n}</h4><div class="cardArt"><img src="${resolveArt(s.c)}" alt=""></div>
        <p>${s.c.txt||''}</p>
        <div class="pips">${pips(s.ph,s.c.p||1)}</div></div>
        <button style="padding:7px 12px;border-radius:10px;border:1px solid var(--line);background:#fff" ${s.advUsed?'disabled':''}>Advance (1⚡)</button>`;
      if(!s.advUsed) d.querySelector('button').onclick=()=>advance(i);
    }
    playerSlots.appendChild(d);
  });

  // AI board
  aiSlots.innerHTML='';
  S.ai.slots.forEach((s,i)=>{
    const d=document.createElement('div'); d.className='slot'; d.innerHTML=`<h5>AI Slot ${i+1}</h5>`;
    if(s) d.innerHTML+=`<div class="marketCard" style="min-width:auto"><h4>${s.c.n}</h4><div class="cardArt"><img src="${resolveArt(s.c)}" alt=""></div><div class="pips">${pips(s.ph,s.c.p||1)}</div></div>`;
    aiSlots.appendChild(d);
  });

  // market
  for(let i=0;i<5;i++){
    const c=S.flowRow[i], el=marketCells[i];
    if(!c){ el.className='marketCard'; el.innerHTML=`<div class="cardArt"></div><p style="opacity:.5">— empty —</p>`; continue; }
    el.className='marketCard'; el.innerHTML='';
    const badge=(c.v!=null)?`<span class="marketBadge">↺ +${c.v}⚡</span>`:'';
    el.innerHTML=`${badge}<h4>${c.n}</h4>
      <div class="cardArt"><img src="${resolveArt(c)}" alt=""></div>
      <p>${c.txt||''}</p>
      <div class="actions"><button ${S.ae>=FLOW_PRICES[i]?'':'disabled'}>Buy (${FLOW_PRICES[i]}⚡)</button></div>`;
    el.querySelector('button').onclick=()=>buyFlow(i);
  }

  // glyphs
  glyphTray.innerHTML=S.glyphs.map(g=>`<button class="glyphTok own"><span class="glyphPeek">${g.n}: ${g.txt||'Glyph'}</span></button>`).join('')||`<span style="font-size:11px;color:#888e93">No glyphs set.</span>`;

  // hand
  renderHand();
}
function renderHand(){
  rRibbon.innerHTML='';
  S.hand.forEach((c,i)=>{
    const card=document.createElement('button'); card.type='button'; card.className='rCard'; card.dataset.index=i;
    card.innerHTML=`<div class="rHead">${c.n}</div>
    <div class="rArt">
      ${(c.v!=null?`<div class="badgeTR">↺ +${c.v}⚡</div>`:'')}
      ${(c.t==='Spell'?`<div class="badgeTL">${'●'.repeat(c.p||1)}</div>`:'')}
      <img src="${resolveArt(c)}" alt="${c.n}">
    </div>
    <div class="rFoot">${c.txt||''}</div>`;
    prepPointer(card,i);
    rRibbon.appendChild(card);
  });
}

/* =========================
   Tap vs Drag (8px threshold)
   ========================= */
function prepPointer(card,i){
  let down=false,drag=false,ghost=null,startX=0,startY=0,downAt=0;
  card.addEventListener('pointerdown',e=>{
    down=true; drag=false; startX=e.clientX; startY=e.clientY; downAt=performance.now();
    card.setPointerCapture?.(e.pointerId); e.preventDefault();
  });
  card.addEventListener('pointermove',e=>{
    if(!down) return;
    // lock to X: ignore vertical for ghost movement
    if(!drag){
      const moved=Math.hypot(e.clientX-startX,e.clientY-startY);
      if(moved>8){
        drag=true;
        ghost=card.cloneNode(true);
        Object.assign(ghost.style,{position:'fixed',left:e.clientX+'px',top:e.clientY+'px',transform:'translate(-50%,-50%) scale(1.02)',pointerEvents:'none',opacity:.95,zIndex:999});
        document.body.appendChild(ghost);
      }
    }else{
      ghost.style.left=e.clientX+'px';
      ghost.style.top=e.clientY+'px';
      highlightDrop(e.clientX,e.clientY);
    }
  });
  function end(e){
    if(!down) return; down=false; card.releasePointerCapture?.(e.pointerId);
    if(drag){
      const idx=dropIndex(e.clientX,e.clientY); if(idx!=null) playFromHandIndex(i,idx);
      if(ghost) ghost.remove(); unhot();
    }else{
      const dur=performance.now()-downAt, moved=Math.hypot(e.clientX-startX,e.clientY-startY);
      if(dur<250 && moved<6) openInspect(i);
    }
  }
  card.addEventListener('pointerup',end);
  card.addEventListener('pointercancel',end);
}
function highlightDrop(x,y){[...document.querySelectorAll('#playerSlots .slot')].forEach(s=>s.classList.toggle('is-hot',hit(s,x,y))); }
function unhot(){[...document.querySelectorAll('#playerSlots .slot')].forEach(s=>s.classList.remove('is-hot'))}
function hit(el,x,y){const r=el.getBoundingClientRect();return x>=r.left&&x<=r.right&&y>=r.top&&y<=r.bottom}
function dropIndex(x,y){const A=[...document.querySelectorAll('#playerSlots .slot')];const i=A.findIndex(s=>hit(s,x,y));return i>-1?i:null}

/* =========================
   Inspect
   ========================= */
function openInspect(i){const c=S.hand[i]; if(!c) return; inspectIndex=i; $('#insTitle').textContent=c.n; $('#insText').textContent=c.txt||''; $('#insArt').src=resolveArt(c); $('#inspect').classList.add('show');}
function closeInspect(){ $('#inspect').classList.remove('show'); inspectIndex=-1; }
$('#btnInspectClose').onclick=closeInspect;
$('#btnInspectPlay').onclick=()=>{ if(inspectIndex>-1){ playFromHandIndex(inspectIndex); closeInspect(); } };
$('#btnInspectChan').onclick=()=>{ if(inspectIndex>-1){ channelFromHandIndex(inspectIndex); closeInspect(); } };

/* =========================
   Actions & Resolve
   ========================= */
function playFromHandIndex(idx,slotIdx=null){
  const c=S.hand[idx]; if(!c) return;
  if(c.t==='Spell'){let s=(slotIdx!=null?slotIdx:S.slots.findIndex(x=>!x)); if(s<0){log("No empty slot."); return;} S.slots[s]={c,ph:1,advUsed:false}; S.hand.splice(idx,1); log(`Play ${c.n} → Slot ${s+1}.`);}
  else if(c.t==='Glyph'){S.glyphs.push(c); S.hand.splice(idx,1); log(`Set glyph: ${c.n}.`);}
  else{S.ae+=(c.v||0); S.disc.push(c); S.hand.splice(idx,1); log(`Cast ${c.n}: +${c.v||0}⚡.`);}
  render();
}
function channelFromHandIndex(idx){const c=S.hand[idx]; if(!c) return; S.ae+=(c.v||0); S.disc.push(c); S.hand.splice(idx,1); log(`Channel ${c.n}: +${c.v||0}⚡.`); render();}
function advance(i){const s=S.slots[i]; if(!s) return; if(S.ae<1){log("Need 1⚡ to advance."); return;} S.ae-=1; s.ph++; s.advUsed=true; if(s.ph>=(s.c.p||1)) resolvePlayer(i); render();}
function resolvePlayer(i){const s=S.slots[i]; if(!s) return; runResolve('you',s.c); S.disc.push(s.c); S.slots[i]=null; render();}
function runResolve(who,c){
  switch(c.eff){
    case 'gain1': if(who==='you'){S.ae+=1; log(`${c.n} resolves: +1⚡.`);} else {S.ai.ae+=1; log(`AI gains +1⚡.`);} break;
    case 'drain1': if(who==='you'){S.ai.ae=Math.max(0,S.ai.ae-1); log(`${c.n}: drain 1⚡ (AI).`);} else {S.ae=Math.max(0,S.ae-1); log(`AI drains 1⚡.`);} break;
    case 'tax': if(who==='you'){log(`${c.n}: foe’s next Advance +1⚡ (sim).`);} else {log(`AI taxes your next Advance (sim).`);} break;
    default:
      if(c.t==='Spell'){
        if(c.n==='Flame Lash'){log((who==='you'?'You':'AI')+" Flame Lash deals 5 total (sim).");}
        else if(c.n==='Ember'){log((who==='you'?'You':'AI')+" Ember deals 2 (sim).");}
        else if(c.n==='Spark Javelin'){log((who==='you'?'You':'AI')+" Spark Javelin deals 2 (sim).");}
        else if(c.n==='Frost Bolt'){log((who==='you'?'You':'AI')+" Frost Bolt slows (sim).");}
        else {log(`${c.n} resolves.`);}
  }}
}

/* =========================
   Simple AI
   ========================= */
function aiDraw(){ if(S.ai.deck.length===0){ if(S.ai.disc.length>0){ S.ai.deck=shuf(S.ai.disc); S.ai.disc=[]; log("AI reshuffles."); } else return; } S.ai.hand.push(S.ai.deck.pop()); }
function aiTurn(){
  while(S.ai.hand.length<5) aiDraw();
  const idxSpell=S.ai.hand.findIndex(x=>x.t==='Spell');
  if(idxSpell>-1){ const c=S.ai.hand.splice(idxSpell,1)[0]; const s=S.ai.slots.findIndex(x=>!x); if(s>-1){ S.ai.slots[s]={c,ph:1,advUsed:false}; log("AI plays "+c.n); } }
  const idxInst=S.ai.hand.findIndex(x=>x.t==='Instant');
  if(idxInst>-1){ const r=S.ai.hand.splice(idxInst,1)[0]; S.ai.ae+=(r.v||0); S.ai.disc.push(r); log("AI channels "+r.n+" (+ "+(r.v||0)+"⚡)"); }
  const sIdx=S.ai.slots.findIndex(s=>s && !s.advUsed && S.ai.ae>0);
  if(sIdx>-1){ S.ai.ae--; S.ai.slots[sIdx].ph++; S.ai.slots[sIdx].advUsed=true; log("AI advances."); if(S.ai.slots[sIdx].ph>= (S.ai.slots[sIdx].c.p||1)){ runResolve('ai',S.ai.slots[sIdx].c); S.ai.disc.push(S.ai.slots[sIdx].c); S.ai.slots[sIdx]=null; } }
  for(let i=4;i>=0;i--){ const c=S.flowRow[i]; if(c && FLOW_PRICES[i] <= (S.ai.ae||0)){ S.ai.ae -= FLOW_PRICES[i]; S.ai.disc.push(c); S.flowRow[i]=null; log("AI buys "+c.n); break; } }
  ensureMarket(); render();
}

/* =========================
   Market
   ========================= */
function ensureMarket(initial=false){ for(let i=0;i<5;i++){ if(!S.flowRow[i]) S.flowRow[i]=drawFlow(); } if(initial) render(); }
function drawFlow(){ if(S.flowDeck.length===0) S.flowDeck=makeFlowDeck(); return S.flowDeck.pop()||null; }
function buyFlow(i){
  const c=S.flowRow[i]; if(!c){log("Empty slot."); return;}
  const cost=FLOW_PRICES[i]; if(S.ae<cost){log("Not enough ⚡."); return;}
  S.ae-=cost; S.disc.push(c); S.flowRow[i]=null; log(`Bought ${c.n} for ${cost}⚡.`); ensureMarket(); render();
}
function slideFlow(){ S.flowRow.pop(); S.flowRow.unshift(drawFlow()); }

/* =========================
   Deck/Discard taps (still useful)
   ========================= */
document.getElementById('chipDeck').onclick = ()=> log(`Deck: ${S.deck.length}`);
document.getElementById('chipDiscard').onclick = ()=> log(`Discard: ${S.disc.length}`);

/* =========================
   Buttons
   ========================= */
fabDraw.onclick=()=>{ if(S.hand.length<HAND_DRAW){ drawCard(); render(); log("Manual draw."); } };
fabEnd.onclick =()=> endTurn();
fabReset.onclick=()=> initGame();

/* =========================
   HUD height → padding (so AI board never hidden)
   ========================= */
(function reserveTopForHUD(){
  const hud=document.getElementById('hud');
  const setPad=()=>document.documentElement.style.setProperty('--hud-h', (hud?.getBoundingClientRect().height||56)+'px');
  setPad(); new ResizeObserver(setPad).observe(hud);
})();

/* =========================
   Boot
   ========================= */
initGame();
</script>
</body>
</html>