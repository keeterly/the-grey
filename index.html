<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Grey ‚Äì Ribbon Hand (Accessible + Mobile)</title>
<style>
  :root{
    --card-w: 140px;
    --card-h: 200px;
    --card-radius: 14px;
    --fan-lift: 24px;       /* how high the focused card lifts */
    --fan-spread: 36px;     /* how far neighbors shift during fan-out */
    --overlap: -90px;       /* base overlap; JS will adjust dynamically */
    --ring: 2px;
    --transition: 140ms ease;
  }

  body{
    margin:0;
    background:#0f1013;
    color:#e9e9ef;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    display:flex;
    flex-direction:column;
    min-height:100dvh;
  }

  header{
    padding:16px 20px;
    border-bottom:1px solid #1d1f25;
    display:flex;align-items:center;gap:12px;
  }
  header h1{font-size:16px;margin:0;font-weight:600;opacity:.9}

  /* Ribbon container */
  .ribbon-wrap{
    position:fixed;
    left:0; right:0; bottom:0;
    padding:14px 10px 22px;
    background:linear-gradient(180deg, rgba(15,16,19,0) 0%, rgba(15,16,19,.85) 40%, rgba(15,16,19,1) 100%);
    backdrop-filter:saturate(1.1) blur(4px);
    border-top:1px solid #1d1f25;
    z-index:40;
  }
  .ribbon{
    position:relative;
    height:calc(var(--card-h) + 20px);
    display:flex;
    align-items:flex-end;
    justify-content:center;
    touch-action:pan-x; /* allow horizontal swipe without hijacking scroll */
    user-select:none;
    overflow-x:auto; /* graceful overflow on tiny screens */
    scrollbar-width:none;
    gap:0; /* spacing handled by transforms */
  }
  .ribbon::-webkit-scrollbar{display:none}

  /* Card base */
  .card{
    position:relative;
    width:var(--card-w);
    height:var(--card-h);
    border-radius:var(--card-radius);
    background:#1a1d24;
    box-shadow:0 6px 18px rgba(0,0,0,.35);
    border:1px solid #2a2f3a;
    display:flex;flex-direction:column;overflow:hidden;
    transform-origin:bottom center;
    transition:transform var(--transition), filter var(--transition), box-shadow var(--transition);
    outline:none;
  }
  .card:focus-visible{
    box-shadow:0 0 0 var(--ring) #7aa2ff, 0 6px 18px rgba(0,0,0,.35);
  }
  .card-header{
    padding:8px 10px 6px;
    font-size:12px;font-weight:700;letter-spacing:.02em;
    background:linear-gradient(180deg,#242a36, #1b202a);
    border-bottom:1px solid #2b3140;
  }
  .card-art{
    flex:1; display:flex; align-items:center; justify-content:center;
    font-size:12px; opacity:.85;
    background:
      radial-gradient(60% 80% at 50% 20%, rgba(255,255,255,.06), rgba(255,255,255,0) 70%),
      linear-gradient(180deg, #12141a, #0f1217);
  }
  .card-footer{
    padding:8px 10px;
    font-size:11px; opacity:.75;
    border-top:1px solid #232836;
    background:#151821;
  }

  /* Stacking handled by inline transform set in JS.
     When expanded, we fan neighbors and lift focused card. */
  .ribbon.expanded .card{
    transition:transform var(--transition);
  }
  .card.is-focused{
    transform:translateY(calc(-1 * var(--fan-lift))) scale(1.04) translateX(var(--dx, 0px));
    z-index:5;
    filter:saturate(1.08);
  }
  .card.is-left,
  .card.is-right{
    z-index:4;
    transform:translateY(-8px) translateX(var(--dx, 0px));
  }

  /* Hover affordance on desktop only */
  @media (hover:hover){
    .card:hover{filter:brightness(1.06);}
  }

  /* Preview panel */
  .preview{
    position:absolute;
    left:50%; transform:translateX(-50%);
    bottom:calc(100% + 12px);
    min-width: min(540px, 92vw);
    max-width: 92vw;
    padding:12px 14px;
    border-radius:12px;
    background:#12141a;
    border:1px solid #2a2f3a;
    box-shadow:0 12px 28px rgba(0,0,0,.45);
    display:none;
    z-index:50;
  }
  .preview.visible{display:block;}
  .preview h3{
    margin:0 0 6px; font-size:14px; font-weight:700;
  }
  .preview p{
    margin:0; font-size:12px; line-height:1.4; opacity:.9;
  }

  /* Simple top ‚Äúspell slots‚Äù to test drag/drop targeting later */
  .board{
    flex:1;
    padding:20px;
    display:grid;
    gap:14px;
    grid-template-columns:repeat(3, minmax(200px, 1fr));
    align-content:start;
  }
  .slot{
    min-height:120px;
    border:2px dashed #2d3342;
    border-radius:12px;
    display:flex; align-items:center; justify-content:center;
    opacity:.9;
  }
  .slot.is-hot{border-color:#7aa2ff; background:rgba(122,162,255,.05);}
  .slot p{opacity:.7; font-size:13px; margin:18px;}
</style>
</head>
<body>
  <header>
    <h1>Spell Board ‚Äì Demo of Improved Ribbon</h1>
  </header>

  <main class="board" id="board">
    <div class="slot" data-slot="1"><p>Spell Slot 1</p></div>
    <div class="slot" data-slot="2"><p>Spell Slot 2</p></div>
    <div class="slot" data-slot="3"><p>Spell Slot 3</p></div>
  </main>

  <section class="ribbon-wrap" aria-label="Your hand">
    <div class="preview" id="preview" role="dialog" aria-live="polite" aria-label="Card Preview"></div>

    <div class="ribbon" id="ribbon" aria-label="Card ribbon" tabindex="-1">
      <!-- Example cards; replace with your data binding -->
      <button class="card" data-id="c1">
        <div class="card-header">Flame Lash</div>
        <div class="card-art">üî• Fire ‚Ä¢ Cost 2</div>
        <div class="card-footer">Deal 3 dmg. If channeled, deal 5 instead.</div>
      </button>

      <button class="card" data-id="c2">
        <div class="card-header">Glacial Ward</div>
        <div class="card-art">‚ùÑÔ∏è Ice ‚Ä¢ Cost 1</div>
        <div class="card-footer">Gain 4 shield. Next hit slowed.</div>
      </button>

      <button class="card" data-id="c3">
        <div class="card-header">Chain Spark</div>
        <div class="card-art">‚ö° Storm ‚Ä¢ Cost 2</div>
        <div class="card-footer">Deal 2 to 3 targets. Forks on crit.</div>
      </button>

      <button class="card" data-id="c4">
        <div class="card-header">Verdant Bloom</div>
        <div class="card-art">üåø Nature ‚Ä¢ Cost 1</div>
        <div class="card-footer">Heal 3. If over-heal, grow a seed.</div>
      </button>

      <button class="card" data-id="c5">
        <div class="card-header">Astral Step</div>
        <div class="card-art">üåå Arcane ‚Ä¢ Cost 0</div>
        <div class="card-footer">Evade next attack. Draw a card.</div>
      </button>
    </div>
  </section>

<script>
  /**
   * Ribbon Hand Controller
   * - Dynamic spacing by hand size
   * - Fan-out on hover/focus/tap (mobile-friendly)
   * - Preview panel content
   * - Pointer-ready hooks for drag/drop integration
   */
  (function(){
    const ribbon = document.getElementById('ribbon');
    const cards = Array.from(ribbon.querySelectorAll('.card'));
    const preview = document.getElementById('preview');
    const board = document.getElementById('board');
    const slots = Array.from(board.querySelectorAll('.slot'));

    let focusIndex = -1;           // which card is focused (for fan-out)
    let baseOverlap = -90;         // px; will be recalculated by dynamic spacing
    let isPointerDown = false;
    let dragGhost = null;          // simple drag ghost element
    let dragFromIndex = -1;

    // ===== Dynamic spacing based on hand size =====
    function layoutStack(){
      const n = cards.length;
      // Reduce overlap as hand shrinks, tighten when it grows.
      // You can tune these clamp values per your art.
      const minOverlap = -40; // least overlap (spacious)
      const maxOverlap = -92; // most overlap (tight)
      const t = Math.min(1, Math.max(0, (n - 4) / 8)); // maps 4..12+ cards ‚ûú 0..1
      baseOverlap = Math.round(maxOverlap + (minOverlap - maxOverlap) * Math.max(0, 1 - t));

      // center the fan: compute left offset so stack is centered
      const totalWidth = (n>0) ? ( (n-1)*(-baseOverlap) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w')) ) : 0;
      const containerW = ribbon.clientWidth;
      const startX = Math.max(10, (containerW - totalWidth) / 2);

      cards.forEach((card, i) => {
        const x = startX + i * (-baseOverlap);
        card.style.transform = `translateX(${x}px)`; // base position (no fan)
        card.style.setProperty('--dx', '0px');
        card.style.zIndex = i + 1; // stable stacking order
        card.dataset.index = i;
      });
    }

    // ===== Fan-out neighbors around focusIndex =====
    function applyFan(){
      ribbon.classList.toggle('expanded', focusIndex >= 0);

      cards.forEach((card, i) => {
        const d = i - focusIndex;

        // Reset role classes
        card.classList.remove('is-focused','is-left','is-right');

        if (focusIndex < 0) {
          card.style.setProperty('--dx','0px');
          return;
        }

        if (d === 0) {
          card.classList.add('is-focused');
          card.style.setProperty('--dx','0px');
        } else if (d === -1 || d === -2) {
          card.classList.add('is-left');
          card.style.setProperty('--dx', `${-Math.abs( (3 - Math.abs(d)) * getSpread() )}px`);
        } else if (d === 1 || d === 2) {
          card.classList.add('is-right');
          card.style.setProperty('--dx', `${(3 - Math.abs(d)) * getSpread()}px`);
        } else {
          // Far cards keep base position (look tidy)
          card.style.setProperty('--dx','0px');
        }
      });
    }

    function getSpread(){
      // Slightly scale spread with current overlap so it always feels roomy
      const base = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fan-spread'));
      const scale = Math.max(0.8, Math.min(1.2, (Math.abs(baseOverlap) / 80)));
      return Math.round(base * scale);
    }

    // ===== Preview content =====
    function showPreview(i){
      if (i < 0 || i >= cards.length){ hidePreview(); return; }
      const card = cards[i];
      const title = card.querySelector('.card-header')?.textContent?.trim() || 'Card';
      const footer = card.querySelector('.card-footer')?.textContent?.trim() || '';
      const art   = card.querySelector('.card-art')?.textContent?.trim() || '';

      preview.innerHTML = `
        <h3>${title}</h3>
        <p><strong>${art}</strong></p>
        <p>${footer}</p>
      `;
      preview.classList.add('visible');

      // Keep preview centered over the focused card if ribbon is scrollable
      // (We compute the card's center relative to the ribbon container)
      const cardRect = card.getBoundingClientRect();
      const ribRect = ribbon.getBoundingClientRect();
      const centerX = cardRect.left + cardRect.width/2;
      const left = Math.min(ribRect.right - 16, Math.max(ribRect.left + 16, centerX));
      // Translate preview horizontally by setting left via transform
      const offset = left - (ribRect.left + ribRect.width/2);
      preview.style.transform = `translateX(calc(-50% + ${offset}px))`;
    }

    function hidePreview(){
      preview.classList.remove('visible');
    }

    function focusCard(i, opts={scroll:true, preview:true}){
      focusIndex = i;
      applyFan();
      if (opts.preview) showPreview(i);
      if (opts.scroll) smartScrollIntoView(i);
    }

    function clearFocus(){
      focusIndex = -1;
      applyFan();
      hidePreview();
    }

    function smartScrollIntoView(i){
      const card = cards[i];
      if (!card) return;
      const rect = card.getBoundingClientRect();
      const viewportPad = 20;
      const overflowLeft = rect.left < viewportPad;
      const overflowRight = rect.right > (window.innerWidth - viewportPad);
      if (overflowLeft || overflowRight){
        card.scrollIntoView({behavior:'smooth', inline:'center', block:'nearest'});
      }
    }

    // ===== Event wiring =====
    // Desktop hover
    if (matchMedia('(hover: hover)').matches){
      cards.forEach((card, i) => {
        card.addEventListener('mouseenter', () => { focusCard(i, {scroll:false, preview:true}); });
      });
      ribbon.addEventListener('mouseleave', clearFocus);
    }

    // Click / tap (mobile + desktop)
    cards.forEach((card, i) => {
      card.addEventListener('click', (e) => {
        // toggle focus on tap; second tap could be used to start drag (if you want)
        if (focusIndex === i){
          // Optional: interpret as "select/confirm"
          // TODO: hook your "play card" or "begin drag" here.
          // startDragFrom(card, i, e);
        } else {
          focusCard(i, {scroll:true, preview:true});
        }
      });

      // Keyboard access
      card.addEventListener('focus', () => focusCard(i, {scroll:false, preview:true}));
      card.addEventListener('blur', () => {
        // only clear if focus moved outside all cards
        setTimeout(() => {
          if (!ribbon.contains(document.activeElement)) clearFocus();
        }, 0);
      });

      // Pointer-ready: long-press to drag (mobile), mouse down to prep
      card.addEventListener('pointerdown', (e) => {
        isPointerDown = true;
        dragFromIndex = i;
        // Optional: you can start drag immediately or after threshold
        // Here we start after small movement (see pointermove)
        card.setPointerCapture(e.pointerId);
      });

      card.addEventListener('pointermove', (e) => {
        if (!isPointerDown || dragFromIndex !== i) return;
        const movedEnough = Math.hypot(e.movementX, e.movementY) > 6;
        if (movedEnough && !dragGhost){
          // Begin a simple ghost ‚Äî replace with your own drag system
          startGhost(card, e);
        }
        if (dragGhost){
          positionGhost(e.clientX, e.clientY);
          updateDropTargets(e.clientX, e.clientY);
        }
      });

      card.addEventListener('pointerup', (e) => {
        if (dragGhost){
          finishGhost(e.clientX, e.clientY, card);
        }
        isPointerDown = false;
        dragFromIndex = -1;
      });
    });

    window.addEventListener('resize', () => {
      layoutStack();
      if (focusIndex >= 0) showPreview(focusIndex);
    });

    // ===== Simple drag ghost + drop target cues (non-invasive demo) =====
    function startGhost(card, e){
      dragGhost = card.cloneNode(true);
      dragGhost.style.position = 'fixed';
      dragGhost.style.pointerEvents = 'none';
      dragGhost.style.opacity = .9;
      dragGhost.style.transform = 'translate(-50%, -50%) scale(1.02)';
      dragGhost.style.boxShadow = '0 12px 28px rgba(0,0,0,.45)';
      dragGhost.style.zIndex = 999;
      document.body.appendChild(dragGhost);
      positionGhost(e.clientX, e.clientY);
      slots.forEach(s => s.classList.add('is-dragging'));
    }
    function positionGhost(x,y){
      if (!dragGhost) return;
      dragGhost.style.left = x+'px';
      dragGhost.style.top = y+'px';
    }
    function updateDropTargets(x,y){
      const el = document.elementFromPoint(x,y);
      slots.forEach(s => s.classList.toggle('is-hot', s === el || s.contains(el)));
    }
    function finishGhost(x,y, sourceCard){
      const el = document.elementFromPoint(x,y);
      const hotSlot = slots.find(s => s === el || s.contains(el));
      if (hotSlot){
        // TODO: hook into your game: play/move card to slot
        // Example placeholder:
        hotSlot.querySelector('p').textContent = `Placed: ${sourceCard.querySelector('.card-header').textContent}`;
      }
      cleanupGhost();
    }
    function cleanupGhost(){
      if (dragGhost && dragGhost.parentNode) dragGhost.parentNode.removeChild(dragGhost);
      dragGhost = null;
      slots.forEach(s => s.classList.remove('is-hot','is-dragging'));
    }

    // ===== Init =====
    layoutStack();

    // If you dynamically add/remove cards, call layoutStack() again.

  })();
</script>
</body>
</html>
