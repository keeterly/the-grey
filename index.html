<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Grey — Spellweavers</title>
<meta name="theme-color" content="#0b0d10" />
<style>
:root{
  --bg:#0b0d10;--panel:#0e1218;--ink:#efece7;--muted:#b9b4ac;
  --line:#1e2631;--accent:#d7b77a;--chip:#121721;--chip-line:#223043;--slot:#0c1118;
  --card:#111621;--card-line:#23344a;

  --card-w:120px; --card-h:172px; --card-radius:12px;
  --transition:140ms ease;
}
*{box-sizing:border-box;margin:0;padding:0}
body{background:var(--bg);color:var(--ink);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;min-height:100vh}
.wrap{padding:12px;max-width:1100px;margin:auto}

/* ===== Floating HUD chips (top corners) ===== */
.hudFloat{
  position:fixed;top:10px;z-index:70;display:flex;flex-direction:column;gap:8px;
  transition: opacity .16s ease, transform .16s ease;
}
.hudFloat.left{left:10px}
.hudFloat.right{right:10px;align-items:flex-end}
.hchip{display:flex;align-items:center;gap:8px;padding:8px 10px;border-radius:12px;background:#0f141d;border:1px solid #273246;color:#cfe2ff;font-size:13px;box-shadow:0 6px 16px rgba(0,0,0,.35)}
.hchip .icon{width:16px;height:16px;display:inline-grid;place-items:center}

/* ===== Sections ===== */
.zone{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:10px;margin-bottom:10px;box-shadow:0 6px 18px rgba(0,0,0,.25) inset}
.subtleTitle{font-weight:700;letter-spacing:.02em;margin-bottom:6px;color:#cfd6e3}

/* Boards */
.slots{display:flex;gap:8px;flex-wrap:wrap}
.slot{flex:1 0 30%;background:#0c1118;border:2px dashed #33465d;border-radius:12px;padding:8px;min-height:140px;position:relative;transition:transform .12s, background .12s, border-color .12s}
.slot h5{font-size:12px;color:#a7a4a0;margin-bottom:6px}
.slot.is-hot{ border-color:#6fa4ff; background:#0d1523; transform:translateY(-1px) }

/* phase pips */
.pips{display:flex;gap:4px;margin-top:4px}
.pip{width:10px;height:10px;border-radius:999px;border:1px solid #36475f;background:#0e1420}
.pip.on{background:#6fa4ff;border-color:#6fa4ff}

/* ===== Glyph tray ===== */
.glyphTray{display:flex;gap:6px;flex-wrap:wrap;margin:6px 0 2px}
.glyphTok{
  position:relative;display:inline-flex;align-items:center;justify-content:center;
  width:44px;height:28px;border-radius:8px;background:#0f141d;border:1px solid #273246;color:#9fb8da;
  font-size:11px;box-shadow:0 3px 10px rgba(0,0,0,.25)
}
.glyphTok::before{content:'✦';opacity:.85;font-size:12px}
.glyphTok.own{cursor:pointer}
.glyphPeek{
  position:absolute;left:50%;bottom:110%;transform:translateX(-50%);
  background:#12141a;border:1px solid #2a2f3a;color:#cfe2ff;padding:6px 8px;border-radius:10px;
  font-size:11px;white-space:nowrap;box-shadow:0 10px 22px rgba(0,0,0,.45);display:none;z-index:8
}
.glyphTok.own:hover .glyphPeek,.glyphTok.own:focus .glyphPeek,.glyphTok.own.peek .glyphPeek{display:block}

/* ===== Aetherflow (synced horizontal scroller + snap + peek dots) ===== */
.flowZone{display:flex;flex-direction:column;gap:8px}
.flowScroller{overflow:auto;scrollbar-width:none;scroll-snap-type: x mandatory}
.flowScroller::-webkit-scrollbar{display:none}
.flowInner{min-width:720px}
.costGrid, .cardGrid{
  display:grid;grid-template-columns:repeat(5, 1fr);gap:10px;align-items:start
}
.costChip{justify-self:center;min-width:42px;text-align:center;font-weight:800;padding:4px 8px;border:1px solid #213145;border-radius:999px;background:#0b111a;color:#d7b77a;font-size:12px}
.marketCard{background:var(--card);border:1px solid var(--card-line);border-radius:14px;padding:10px;min-height:110px;position:relative;box-shadow:0 6px 16px rgba(0,0,0,.28);scroll-snap-align:start}
.marketCard h4{font-size:14px;color:#d7b77a;margin-bottom:4px}
.marketCard p{font-size:12px;color:#b9b4ac;margin-bottom:6px}
.marketCard .actions{display:flex;gap:6px}
.marketBadge{position:absolute;top:8px;right:10px;border:1px solid #2b3a51;background:#0b111a;color:#a9d0ff;padding:2px 6px;border-radius:8px;font-size:11px}
.placeholder{opacity:.35;display:grid;place-items:center;border-style:dashed}
.marketCard.afford{ box-shadow: 0 8px 22px rgba(111,164,255,.22); border-color:#2e3e56 }
.marketCard.na .actions button{opacity:.55;cursor:not-allowed}

/* Flow peek dots */
.peekDots{display:flex;gap:6px;justify-content:center;margin-top:2px}
.peekDot{width:6px;height:6px;border-radius:999px;background:#2a3241}
.peekDot.on{background:#6fa4ff}

/* ===== Top toast log ===== */
.topLog{position:fixed;top:8px;left:50%;transform:translateX(-50%);background:#111724;border:1px solid #273246;color:#cfe2ff;border-radius:12px;padding:8px 12px;box-shadow:0 10px 28px rgba(0,0,0,.45);z-index:80;display:none;max-width:92vw;font-size:12px;line-height:1.35}
.topLog.show{display:block;animation:pop .18s ease-out}
.topLog .item{opacity:.92}.topLog .item + .item{margin-top:4px;border-top:1px solid #233145;padding-top:4px}
@keyframes pop{from{transform:translateX(-50%) translateY(-6px);opacity:0}to{transform:translateX(-50%) translateY(0);opacity:1}}

/* ===== Ribbon Hand ===== */
.ribbon-wrap{position:fixed;left:0;right:0;bottom:0;z-index:40;padding:8px 6px calc(10px + env(safe-area-inset-bottom));background:linear-gradient(0deg,#0e1218,#151b26);border-top:1px solid #1e2631;box-shadow:0 -2px 10px rgba(0,0,0,.4)}
.ribbon{display:flex;align-items:flex-end;justify-content:flex-start;gap:4px;padding:0 6px;height:110px;overflow-x:auto;scrollbar-width:none;user-select:none;touch-action:pan-x;scroll-snap-type:x mandatory}
.ribbon::-webkit-scrollbar{display:none}
.rCard{width:var(--card-w);height:var(--card-h);border-radius:var(--card-radius);overflow:hidden;background:#13161d;border:1px solid #2a2f3a;box-shadow:0 6px 18px rgba(0,0,0,.35);transform:translateY(46%);transform-origin:bottom center;transition:transform var(--transition),filter var(--transition),box-shadow var(--transition);outline:none;display:flex;flex-direction:column;-webkit-user-select:none;user-select:none;scroll-snap-align:start}
.rHead{padding:6px 8px 5px;font-size:11px;font-weight:800;letter-spacing:.02em;background:linear-gradient(180deg,#242a36,#1b202a);border-bottom:1px solid #2b3140;color:#7aa2ff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.rArt{position:relative;flex:1;background:#0f1217;display:grid;place-items:center}
.rArt img{width:100%;height:100%;object-fit:cover;display:block;filter:saturate(1.05) contrast(1.02)}
.rArt .fallback{font-size:11px;opacity:.75;padding:6px;text-align:center}
.rFoot{padding:6px 8px;font-size:10.5px;opacity:.9;border-top:1px solid #232836;background:#151821;line-height:1.25}
.badgeTL,.badgeTR{position:absolute;top:6px;padding:2px 6px;border-radius:8px;font-size:10px;font-weight:700;background:#0b111a;border:1px solid #2a3342;color:#a9d0ff;box-shadow:0 2px 8px rgba(0,0,0,.25)}
.badgeTL{left:6px}.badgeTR{right:6px}

/* ===== Inspect panel (large readable card info + art) ===== */
.inspectBack{
  position:fixed;inset:0;z-index:75;background:rgba(6,8,12,.52);
  display:none;align-items:flex-end;justify-content:center;padding-bottom:128px
}
.inspectBack.show{display:flex}
.inspectCard{
  min-width:min(560px,92vw);max-width:92vw;background:#12141a;border:1px solid #2a2f3a;border-radius:14px;box-shadow:0 16px 40px rgba(0,0,0,.55);
  padding:12px 14px
}
.inspectCard h3{margin:0 0 6px;font-size:16px;font-weight:900;color:#d7b77a}
.inspectCard p{margin:0 0 8px;font-size:13px;line-height:1.45;color:#cfd6e3}
.inspectCard .artBox{height:160px;border-radius:10px;overflow:hidden;margin:6px 0 10px;border:1px solid #222a36;background:#0f1218;display:grid;place-items:center}
.inspectCard .artBox img{width:100%;height:100%;object-fit:cover}
.inspectDots{display:flex;gap:6px;margin-bottom:8px}
.inspectDot{width:14px;height:14px;border-radius:999px;border:1px solid #36475f;background:#0e1420}
.inspectDot.on{background:#6fa4ff;border-color:#6fa4ff}
.inspectActions{display:flex;gap:8px;justify-content:flex-end}
.inspectActions button{padding:8px 12px;border-radius:10px;border:1px solid #273246;background:#0f141d;color:#cfe2ff;font-size:13px;cursor:pointer}

/* ===== Deck & Discard chips ===== */
.deckBar{position:fixed;left:10px;bottom:120px;z-index:50;display:flex;gap:6px;transition: opacity .16s ease, transform .16s ease}
.chip{display:flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#0f141d;border:1px solid #273246;color:#cfe2ff;font-size:12px;box-shadow:0 6px 18px rgba(0,0,0,.35)}
.chip svg{width:14px;height:14px;opacity:.9}
.chip .narrow{font-variant-numeric:tabular-nums}

/* ===== Speed-dial FAB ===== */
.fabDial{position:fixed;right:10px;bottom:120px;z-index:50;display:flex;flex-direction:column;align-items:flex-end;gap:10px;transition: opacity .16s ease, transform .16s ease}
.fab{width:48px;height:48px;border-radius:999px;background:#0f141d;border:1px solid #273246;display:grid;place-items:center;color:#cfe2ff;box-shadow:0 8px 20px rgba(0,0,0,.45);cursor:pointer}
.fab svg{width:22px;height:22px}
.fab.small{width:42px;height:42px}
.dialActions{display:grid;gap:8px;transform-origin:bottom right;transition:transform .14s ease, opacity .14s ease;opacity:0;transform:scale(.9);pointer-events:none}
.fabDial.open .dialActions{opacity:1;transform:scale(1);pointer-events:auto}
.smartHide{ opacity:.15; transform: translateY(6px); pointer-events:none; }
.hidden{display:none}
</style>
</head>
<body>
<!-- Floating HUD -->
<div class="hudFloat left">
  <div class="hchip" title="Your HP"><span class="icon">♥</span><b id="hp">5</b></div>
  <div class="hchip" title="Your Aether"><span class="icon">⚡</span><b id="ae">0</b></div>
  <div class="hchip" style="padding:4px 8px" title="Turn"><span id="turnTag" style="font-size:12px">Turn 1</span></div>
</div>
<div class="hudFloat right">
  <div class="hchip" title="AI HP">AI&nbsp;<span class="icon">♥</span><b id="aiHp">5</b></div>
  <div class="hchip" title="AI Aether"><span class="icon">⚡</span><b id="aiAe">0</b></div>
  <div class="hchip" title="AI Glyphs"><span class="icon">✦</span><b id="aiGlyphs">0</b></div>
</div>

<!-- toast -->
<div id="topLog" class="topLog" aria-live="polite"></div>

<div class="wrap">
  <!-- AI Board -->
  <div class="zone">
    <div class="subtleTitle">AI Board</div>
    <div class="slots" id="aiSlots"></div>
  </div>

  <!-- Aetherflow -->
  <div class="zone">
    <div class="subtleTitle" style="text-align:center">Aetherflow</div>
    <div class="flowZone">
      <div class="flowScroller" id="flowScroll">
        <div class="flowInner">
          <div class="costGrid" id="flowCosts"></div>
          <div class="cardGrid" id="flowGrid"></div>
        </div>
      </div>
      <div class="peekDots" id="peekDots"></div>
    </div>
  </div>

  <!-- Player Board + Glyphs -->
  <div class="zone">
    <div class="subtleTitle">Your Board</div>
    <div class="glyphTray" id="glyphTray"></div>
    <div class="slots" id="playerSlots"></div>
  </div>
</div>

<!-- Deck & Discard chips -->
<div class="deckBar" aria-label="Deck and Discard">
  <div class="chip" title="Deck">
    <svg viewBox="0 0 24 24" fill="none"><rect x="5" y="3" width="12" height="18" rx="2" ry="2" stroke="#a9d0ff" stroke-width="1.4"/><rect x="8" y="6" width="12" height="18" rx="2" ry="2" stroke="#a9d0ff" stroke-width="1.2" opacity=".6"/></svg>
    <span id="deckCount" class="narrow">0</span>
  </div>
  <div class="chip" title="Discard">
    <svg viewBox="0 0 24 24" fill="none"><path d="M6 12h12" stroke="#a9d0ff" stroke-width="1.4"/><path d="M8 16h8" stroke="#a9d0ff" stroke-width="1.4"/><rect x="5" y="4" width="14" height="16" rx="2" stroke="#a9d0ff" stroke-width="1.2"/></svg>
    <span id="discardCount" class="narrow">0</span>
  </div>
</div>

<!-- Speed-dial FAB -->
<div class="fabDial" id="fabDial" aria-label="Turn controls">
  <div class="dialActions">
    <button id="fabDraw" class="fab small" title="Draw">
      <svg viewBox="0 0 24 24" fill="none"><path d="M12 5v14M7 10l5-5 5 5" stroke="#cfe2ff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
    </button>
    <button id="fabEnd" class="fab small" title="End Turn">
      <svg viewBox="0 0 24 24" fill="none"><path d="M5 12h10" stroke="#cfe2ff" stroke-width="1.6" stroke-linecap="round"/><path d="M13 7l5 5-5 5" stroke="#cfe2ff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
    </button>
    <button id="fabReset" class="fab small" title="Reset">
      <svg viewBox="0 0 24 24" fill="none"><path d="M4 12a8 8 0 1 0 3-6" stroke="#cfe2ff" stroke-width="1.6" stroke-linecap="round"/><path d="M4 4v4h4" stroke="#cfe2ff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
    </button>
  </div>
  <button id="fabMain" class="fab" title="Actions">
    <svg viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="#cfe2ff" stroke-width="1.8" stroke-linecap="round"/></svg>
  </button>
</div>

<!-- Ribbon Hand -->
<section class="ribbon-wrap" aria-label="Your hand">
  <div class="ribbon" id="ribbon" tabindex="-1"></div>
</section>

<!-- Inspect panel -->
<div id="inspect" class="inspectBack" role="dialog" aria-modal="true">
  <div class="inspectCard">
    <h3 id="insTitle">Card</h3>
    <div class="artBox"><img id="insArt" alt="" loading="lazy"></div>
    <div class="inspectDots" id="insDots"></div>
    <p id="insText"></p>
    <div class="inspectActions">
      <button id="btnInspectPlay">Play/Set</button>
      <button id="btnInspectChan">Channel</button>
      <button id="btnInspectClose" aria-label="Close">Close</button>
    </div>
  </div>
</div>

<script>
/* ===== CONFIG / CARDS ===== */
const HAND_DRAW = 5;
const DISCARD_AT_END = true;

const STARTER = [
  {n:'Apprentice Bolt', t:'Spell',   txt:'Deal 1.', p:1, artKey:'apprentice-bolt'},
  {n:'Apprentice Bolt', t:'Spell',   txt:'Deal 1.', p:1, artKey:'apprentice-bolt'},
  {n:'Apprentice Bolt', t:'Spell',   txt:'Deal 1.', p:1, artKey:'apprentice-bolt'},
  {n:'Kindle',          t:'Spell',   txt:'On resolve: +1⚡.', p:2, eff:'gain1', artKey:'kindle'},
  {n:'Glacial Ward',    t:'Glyph',   txt:'Prevent 1 next hit.', eff:'g_barrier', artKey:'glacial-ward'},
  {n:'Mirror Ward',     t:'Glyph',   txt:'Reflect next damage (sim).', eff:'g_mirror', artKey:'mirror-ward'},
  {n:'Ward Sigil',      t:'Glyph',   txt:'Prevent 1 (sim).', eff:'g_barrier', artKey:'ward-sigil'},
  {n:'Meditate',        t:'Instant', txt:'↺ +1⚡ (or play +1⚡).', v:1, artKey:'meditate'}
];
const ECON_CARDS = [
  {n:'Aether Pebble', t:'Instant', txt:'↺ +1⚡ (or play +1⚡).', v:1, artKey:'aether-pebble'},
  {n:'Aether Shard',  t:'Instant', txt:'↺ +2⚡ (or play +2⚡).', v:2, artKey:'aether-shard'},
  {n:'Aether Core',   t:'Instant', txt:'↺ +3⚡ (or play +3⚡).', v:3, artKey:'aether-core'}
];
const OFFENSE_CARDS = [
  {n:'Spark Javelin', t:'Spell', txt:'Deal 2.', p:1, v:1, artKey:'spark-javelin'},
  {n:'Flame Lash',    t:'Spell', txt:'Deal 2 then 3.', p:2, v:0, artKey:'flame-lash'},
  {n:'Ember',         t:'Spell', txt:'Deal 2.', p:1, v:0, artKey:'ember'},
  {n:'Frost Bolt',    t:'Spell', txt:'Deal 1; slow next hit (sim).', p:2, v:0, artKey:'frost-bolt'},
  {n:'Siphon Hex',    t:'Spell', txt:'Drain 1⚡ from foe.', p:2, v:1, eff:'drain1', artKey:'siphon-hex'},
  {n:'Stonewall',     t:'Spell', txt:'+1 advance tax (foe).', p:2, v:0, eff:'tax', artKey:'stonewall'}
];
const FLOW_POOL = [...ECON_CARDS, ...OFFENSE_CARDS];
const FLOW_PRICES = [4,3,2,2,2];

const ART_ROOT = 'assets/art/standard/';
const slug = s => (s||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
const resolveArt = c => ART_ROOT + (c.artKey || slug(c.n||c.name||'card')) + '.jpg';

/* ===== DOM ===== */
const hp=qs('#hp'), aiHp=qs('#aiHp'), ae=qs('#ae'), aiAe=qs('#aiAe'), aiGlyphs=qs('#aiGlyphs');
const deckCount=qs('#deckCount'), discardCount=qs('#discardCount');
const flowCosts=qs('#flowCosts'), flowGrid=qs('#flowGrid'), flowScroll=qs('#flowScroll'), peekDots=qs('#peekDots');
const playerSlots=qs('#playerSlots'), aiSlots=qs('#aiSlots'), glyphTray=qs('#glyphTray');
const rRibbon=qs('#ribbon'), topLog=qs('#topLog');
const fabDial=qs('#fabDial'), fabMain=qs('#fabMain'), fabDraw=qs('#fabDraw'), fabEnd=qs('#fabEnd'), fabReset=qs('#fabReset');
const inspect=qs('#inspect'), insTitle=qs('#insTitle'), insText=qs('#insText'), insDots=qs('#insDots'), insArt=qs('#insArt');
const turnTag=qs('#turnTag');
const chromeEls = [
  qsa('.hudFloat.left')[0],
  qsa('.hudFloat.right')[0],
  qs('.deckBar'),
  fabDial
];

/* ===== STATE ===== */
let S={};
let rCards=[], isPointerDown=false,isDragging=false,dragGhost=null,dragFrom=-1,longPressTimer=null;
let turnLog=[], logHideTimer, inspectIndex=-1;

/* ===== HELPERS ===== */
function qs(s, root=document){ return root.querySelector(s); }
function qsa(s, root=document){ return Array.from(root.querySelectorAll(s)); }
function uid(){return Math.random().toString(36).slice(2,9);}
function shuf(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
function makeStarterDeck(){ return shuf(STARTER.map(x=>Object.assign({id:uid()},x))); }
function makeFlowDeck(){ return shuf(FLOW_POOL.map(x=>Object.assign({id:uid()},x))); }

/* ===== TOAST ===== */
function toastShow(){ topLog.classList.add('show'); clearTimeout(logHideTimer); logHideTimer=setTimeout(()=>{ topLog.classList.remove('show'); }, 2200); }
function toastRender(){ topLog.innerHTML = turnLog.slice(-3).map(x=>`<div class="item">${x}</div>`).join(''); toastShow(); }
function log(msg){ turnLog.push(msg); toastRender(); }
function logResetTurn(){ turnLog=[]; topLog.classList.remove('show'); }

/* ===== INIT / TURN FLOW ===== */
function initGame(){
  S={
    hp:5, ae:0, deck:makeStarterDeck(), hand:[], disc:[],
    slots:[null,null,null], glyphs:[],
    ai:{hp:5, ae:0, deck:makeStarterDeck(), hand:[], disc:[], slots:[null,null,null], glyphs:[]},
    flowDeck:makeFlowDeck(), flowRow:[null,null,null,null,null],
    turn:1, taxes:0, lastInstant:null
  };
  ensureMarketComposition(true);
  startTurn(true);
}
function startTurn(first=false){
  if(!first) S.turn++;
  logResetTurn();
  while(S.hand.length < HAND_DRAW){ drawCard(); }
  render();
  log(`Turn ${S.turn} — drew to ${HAND_DRAW}.`);
}
function endTurn(){
  S.slots.forEach(s=>{ if(s) s.advUsed=false; });
  slideFlow();
  if(S.hand.length){
    const n=S.hand.length; S.disc.push(...S.hand); S.hand.length=0;
    log(`End Turn: discarded ${n} card${n>1?'s':''}.`);
  } else log("End Turn.");
  render();
  setTimeout(()=>startTurn(false), 350);
}

/* ===== RENDER ===== */
function render(){
  hp.textContent=S.hp; aiHp.textContent=S.ai.hp; ae.textContent=S.ae; aiAe.textContent=S.ai.ae||0;
  deckCount.textContent=S.deck.length; discardCount.textContent=S.disc.length;
  aiGlyphs.textContent = S.ai.glyphs.length;
  turnTag.textContent=`Turn ${S.turn}`;

  // Glyph tray (yours)
  glyphTray.innerHTML = S.glyphs.map(g=>`<button class="glyphTok own"><span class="glyphPeek">${g.n}: ${g.txt||'Glyph'}</span></button>`).join('')
    || `<span style="font-size:11px;color:#7d8aa4;opacity:.8">No glyphs set.</span>`;

  // Player board
  playerSlots.innerHTML="";
  S.slots.forEach((s,i)=>{
    const d=document.createElement('div'); d.className='slot'; d.innerHTML=`<h5>Slot ${i+1}</h5>`;
    if(s){
      d.innerHTML += `
        <div class="marketCard" style="min-width:auto;max-width:none;margin-bottom:6px">
          <h4>${s.c.n}</h4>
          <p>${s.c.txt||''}</p>
          <div class="pips">${renderPips(s.ph, s.c.p||1)}</div>
        </div>
        <button ${s.advUsed?'disabled':''}>Advance (1⚡)</button>`;
      if(!s.advUsed) d.querySelector('button').onclick=()=>advance(i);
    }
    playerSlots.appendChild(d);
  });

  // AI board
  aiSlots.innerHTML="";
  S.ai.slots.forEach((s,i)=>{
    const d=document.createElement('div'); d.className='slot'; d.innerHTML=`<h5>AI Slot ${i+1}</h5>`;
    if(s){
      d.innerHTML += `
        <div class="marketCard" style="min-width:auto;max-width:none">
          <h4>${s.c.n}</h4>
          <div class="pips">${renderPips(s.ph, s.c.p||1)}</div>
        </div>`;
    }
    aiSlots.appendChild(d);
  });

  // Aetherflow — synced scroller + affordability
  flowCosts.innerHTML = FLOW_PRICES.map(c=>`<div class="costChip">${c}</div>`).join('');
  flowGrid.innerHTML="";
  for (let i = 0; i < FLOW_PRICES.length; i++) {
    const c = S.flowRow[i];
    const div = document.createElement('div');
    div.className = 'marketCard';
    if (!c) {
      div.classList.add('placeholder');
      div.innerHTML = '— empty —';
    } else {
      const cost = FLOW_PRICES[i];
      const canBuy = S.ae >= cost;
      if (canBuy) div.classList.add('afford'); else div.classList.remove('afford');
      if (!canBuy) div.classList.add('na'); else div.classList.remove('na');

      const badge = (c.v != null) ? `<span class="marketBadge">↺ +${c.v}⚡</span>` : "";
      div.innerHTML = `
        ${badge}
        <h4>${c.n}</h4>
        <p>${c.txt}</p>
        <div class="actions">
          <button ${canBuy ? "" : "disabled"}>Buy (${cost}⚡)</button>
        </div>
      `;
      div.querySelector('button').onclick = () => buyFlowCard(i);
    }
    flowGrid.appendChild(div);
  }
  renderPeekDots();

  renderRibbon();
}
function renderPips(cur,total){ let h=''; for(let i=1;i<=total;i++){ h+=`<span class="pip ${i<=cur?'on':''}"></span>`; } return h; }

/* ===== Peek dots for Aetherflow ===== */
function renderPeekDots(){
  peekDots.innerHTML='';
  for(let i=0;i<FLOW_PRICES.length;i++){
    const d=document.createElement('div'); d.className='peekDot'; d.dataset.idx=i;
    peekDots.appendChild(d);
  }
  updatePeekDots();
}
function updatePeekDots(){
  const dots = qsa('.peekDot', peekDots);
  const center = flowScroll.scrollLeft + flowScroll.clientWidth/2;
  // find the nearest column center by card positions
  const cards = qsa('.cardGrid .marketCard', flowScroll);
  let best = 0, bestDist = Infinity;
  cards.forEach((el,i)=>{
    const r = el.getBoundingClientRect();
    const elCenter = (r.left + r.right)/2 + flowScroll.scrollLeft - flowScroll.getBoundingClientRect().left;
    const d = Math.abs(elCenter - center);
    if (d < bestDist){ bestDist = d; best = i; }
  });
  dots.forEach((d,i)=> d.classList.toggle('on', i===best));
}
flowScroll.addEventListener('scroll', ()=>{ updatePeekDots(); }, {passive:true});

/* ===== RIBBON + Inspect ===== */
function renderRibbon(){
  rRibbon.innerHTML='';
  S.hand.forEach((c,i)=>{
    const b=document.createElement('button'); b.className='rCard'; b.type='button'; b.dataset.index=i;

    const h=document.createElement('div'); h.className='rHead'; h.textContent=c.n;

    const art=document.createElement('div'); art.className='rArt';
    const img=document.createElement('img'); img.src=resolveArt(c); img.alt=c.n+' artwork'; img.loading='lazy';
    const fb=document.createElement('div'); fb.className='fallback'; fb.textContent=c.t;
    art.appendChild(img); art.appendChild(fb);
    img.addEventListener('load',()=>{ fb.style.display='none'; });
    img.addEventListener('error',()=>{ fb.style.display='grid'; img.style.display='none'; });

    if (c.v!=null){ const tr=document.createElement('div'); tr.className='badgeTR'; tr.textContent='↺ +'+c.v+'⚡'; art.appendChild(tr); }
    if (c.t==='Spell'){ const tl=document.createElement('div'); tl.className='badgeTL'; tl.textContent='●'.repeat(c.p||1); art.appendChild(tl); }

    const f=document.createElement('div'); f.className='rFoot'; f.textContent=c.txt||'';

    b.appendChild(h); b.appendChild(art); b.appendChild(f);
    // tap -> Inspect
    b.addEventListener('click',()=>openInspect(i));
    // drag for quick play
    prepDrag(b,i);
    rRibbon.appendChild(b);
  });

  rCards=qsa('.rCard');
}

/* Inspect modal */
function openInspect(i){
  const c=S.hand[i]; if(!c) return;
  inspectIndex = i;
  insTitle.textContent = c.n;
  insText.textContent = c.txt || '';
  insArt.src = resolveArt(c); insArt.alt = c.n + ' artwork';
  insDots.innerHTML = (c.t === 'Spell')
    ? Array.from({length: (c.p||1)}, (_,k)=>`<span class="inspectDot ${k===0?'on':''}"></span>`).join('')
    : '';
  inspect.classList.add('show');
}
function closeInspect(){ inspect.classList.remove('show'); inspectIndex=-1; }
qs('#btnInspectClose').onclick=closeInspect;
qs('#btnInspectPlay').onclick = ()=>{ if(inspectIndex>-1){ playFromHandIndex(inspectIndex,null); closeInspect(); } };
qs('#btnInspectChan').onclick = ()=>{ if(inspectIndex>-1){ channelFromHandIndex(inspectIndex); closeInspect(); } };
inspect.addEventListener('click',e=>{ if(e.target===inspect) closeInspect(); });

/* drag helpers */
function prepDrag(card,i){
  card.addEventListener('dragstart',e=>e.preventDefault());
  card.addEventListener('pointerdown',e=>{
    isPointerDown=true; isDragging=false; dragFrom=i;
    card.setPointerCapture(e.pointerId);
    clearTimeout(longPressTimer);
    longPressTimer=setTimeout(()=>{ if(!isDragging) openInspect(i); },350);
    e.preventDefault();
  });
  card.addEventListener('pointermove',e=>{
    const slots=[...qsa('#playerSlots .slot')];
    if(!isPointerDown || dragFrom!==i) return;
    const moved=Math.hypot(e.movementX,e.movementY)>6;
    if(moved && !isDragging){ isDragging=true; clearTimeout(longPressTimer); startGhost(card,e); }
    if(isDragging){ positionGhost(e.clientX,e.clientY); updateDropTargets(e.clientX,e.clientY, slots); }
  });
  card.addEventListener('pointerup',e=>{
    clearTimeout(longPressTimer);
    const slots=[...qsa('#playerSlots .slot')];
    if(isDragging){
      const slotIndex=finishGhost(e.clientX,e.clientY, slots);
      if(slotIndex!=null) playFromHandIndex(i, slotIndex);
      cleanupGhost(slots);
    } else { cleanupGhost(slots); }
  });
  card.addEventListener('pointercancel',()=>cleanupGhost([...qsa('#playerSlots .slot')]));
}
function startGhost(card,e){
  dragGhost=card.cloneNode(true);
  Object.assign(dragGhost.style,{position:'fixed',left:'0px',top:'0px',transform:'translate(-50%,-50%) scale(1.02)',pointerEvents:'none',opacity:.95,zIndex:999,boxShadow:'0 12px 28px rgba(0,0,0,.45)'});
  document.body.appendChild(dragGhost);
  positionGhost(e.clientX,e.clientY);
}
function positionGhost(x,y){ if(dragGhost){ dragGhost.style.left=x+'px'; dragGhost.style.top=y+'px'; } }
function updateDropTargets(x,y,slots){ const el=document.elementFromPoint(x,y); slots.forEach(s=> s.classList.toggle('is-hot', s===el || (el && s.contains(el)))); }
function finishGhost(x,y,slots){ const el=document.elementFromPoint(x,y); const idx=slots.findIndex(s=> s===el || (el && s.contains(el))); return idx>-1 ? idx : null; }
function cleanupGhost(slots){
  if(dragGhost&&dragGhost.parentNode) dragGhost.parentNode.removeChild(dragGhost);
  dragGhost=null; isDragging=false; isPointerDown=false; dragFrom=-1;
  slots.forEach(s=>s.classList.remove('is-hot'));
}

/* ===== GAMEPLAY ===== */
function drawCard(){
  if(S.deck.length===0){
    if(S.disc.length===0){ log("No cards to draw."); return; }
    S.deck = shuf(S.disc); S.disc = []; log("You reshuffle.");
  }
  S.hand.push(S.deck.pop());
}
function playFromHandIndex(idx, dropSlotIndex=null){
  const c=S.hand[idx]; if(!c) return;
  if(c.t==="Spell"){
    let slot=dropSlotIndex!=null?dropSlotIndex:S.slots.findIndex(x=>!x);
    if(slot<0){ log("No empty slot."); return; }
    S.slots[slot]={c,ph:1,advUsed:false};
    S.hand.splice(idx,1);
    log(`Play ${c.n} → Slot ${slot+1}.`);
  } else if(c.t==="Glyph"){
    S.glyphs.push(c); S.hand.splice(idx,1);
    log(`Set glyph: ${c.n}.`);
  } else { // Instant
    S.ae+=(c.v||0); S.disc.push(c); S.hand.splice(idx,1); S.lastInstant=c;
    log(`Cast ${c.n}: +${c.v||0}⚡.`);
  }
  render();
}
function channelFromHandIndex(idx){
  const c=S.hand[idx]; if(!c) return;
  S.ae += (c.v||0);
  S.disc.push(c);
  S.hand.splice(idx,1);
  log(`Channel ${c.n}: +${c.v||0}⚡.`);
  render();
}
function advance(i){
  const s=S.slots[i]; if(!s) return;
  if(S.ae<1){ log("Need 1⚡ to advance."); return; }
  S.ae-=1; s.ph++; s.advUsed=true;
  if(s.ph >= (s.c.p||1)){ resolvePlayer(i); }
  render();
}
function resolvePlayer(idx){
  const s=S.slots[idx]; if(!s) return;
  runResolve('you', s.c);
  S.disc.push(s.c);
  S.slots[idx]=null;
  render();
}
function runResolve(who,c){
  switch(c.eff){
    case 'gain1': if(who==='you'){ S.ae+=1; log(`${c.n} resolves: +1⚡.`); } break;
    case 'drain1': if(who==='you'){ log(`${c.n}: drain 1⚡ (sim).`); } break;
    case 'tax': if(who==='you'){ log(`${c.n}: foe’s next Advance costs +1⚡ (sim).`);} break;
    default:
      if(c.t==='Spell'){
        if(c.n==='Flame Lash'){ log("Flame Lash deals 5 total (2+3) (sim)."); }
        else if(c.n==='Ember'){ log("Ember deals 2 (sim)."); }
        else if(c.n==='Spark Javelin'){ log("Spark Javelin deals 2 (sim)."); }
        else if(c.n==='Frost Bolt'){ log("Frost Bolt deals 1; slows next hit (sim)."); }
        else { log(`${c.n} resolves.`); }
      } else { log(`${c.n} resolves.`); }
  }
}

/* ===== MARKET ===== */
function buyFlowCard(i){
  const c=S.flowRow[i]; if(!c){ log("Empty slot."); return; }
  const cost=FLOW_PRICES[i];
  if(S.ae<cost){ log("Not enough ⚡."); return; }
  S.ae-=cost; S.disc.push(c); S.flowRow[i]=null;
  log(`Bought ${c.n} for ${cost}⚡.`);
  ensureMarketComposition();
  render();
}
function slideFlow(){
  S.flowRow.pop();
  S.flowRow.unshift(drawFromFlowDeck());
  ensureMarketComposition();
}
function drawFromFlowDeck(){
  if(S.flowDeck.length===0) S.flowDeck=makeFlowDeck();
  return S.flowDeck.pop()||null;
}
function ensureMarketComposition(initial=false){
  for(let j=0;j<S.flowRow.length;j++){ if(S.flowRow[j]==null) S.flowRow[j]=drawFromFlowDeck(); }
  let hasEcon = S.flowRow.some(c=>c && c.v>0);
  let hasOff  = S.flowRow.some(c=>c && c.t==='Spell');
  if(!hasEcon){ const econ = shuf(ECON_CARDS.slice()).pop(); S.flowRow[S.flowRow.length-1]=Object.assign({id:uid()},econ); }
  if(!hasOff){ const off = shuf(OFFENSE_CARDS.slice()).pop(); S.flowRow[0]=Object.assign({id:uid()},off); }
  if(initial) render();
}

/* ===== Speed-dial FAB ===== */
fabMain.addEventListener('click', ()=> fabDial.classList.toggle('open'));
fabDraw.onclick = ()=>{ if(S.hand.length<HAND_DRAW){ drawCard(); render(); log("Manual draw."); } };
fabEnd.onclick  = ()=> endTurn();
fabReset.onclick= ()=> initGame();

/* ===== Smart-hide chrome while scrolling ===== */
let lastY = window.scrollY, hideTimer;
function updateSmartHide() {
  const dy = window.scrollY - lastY; lastY = window.scrollY;
  const goingDown = dy > 2;
  chromeEls.forEach(el => el && el.classList.toggle('smartHide', goingDown));
  clearTimeout(hideTimer);
  hideTimer = setTimeout(() => chromeEls.forEach(el => el && el.classList.remove('smartHide')), 300);
}
window.addEventListener('scroll', updateSmartHide, { passive: true });
['touchstart','pointerdown','wheel','keydown'].forEach(evt =>
  window.addEventListener(evt, () => chromeEls.forEach(el => el && el.classList.remove('smartHide')), { passive:true })
);

/* ===== Boot ===== */
initGame();
</script>
</body>
</html>