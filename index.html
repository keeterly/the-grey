<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Grey – Integrated (Ribbon + Standard Artwork)</title>

<style>
  :root{
    --card-w: 140px;
    --card-h: 200px;
    --card-radius: 14px;
    --fan-lift: 24px;
    --fan-spread: 36px;
    --transition: 140ms ease;
  }
  body{
    margin:0; background:#0f1013; color:#e9e9ef;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    display:flex; flex-direction:column; min-height:100dvh;
  }
  header{padding:12px 16px; border-bottom:1px solid #1d1f25;}
  header h1{margin:0; font-size:14px; font-weight:700; opacity:.9}

  /* ==== YOUR EXISTING BOARD/UI remains unchanged ==== */
  .board{flex:1; padding:16px;}
  /* Example slots (keep your existing ones) */
  .slots{display:grid; grid-template-columns:repeat(3,minmax(220px,1fr)); gap:14px;}
  .slot{min-height:120px; border:2px dashed #2d3342; border-radius:12px; display:flex; align-items:center; justify-content:center;}
  .slot.is-hot{border-color:#7aa2ff; background:rgba(122,162,255,.05);}

  /* ==== Ribbon layer (new) ==== */
  .ribbon-wrap{
    position:fixed; left:0; right:0; bottom:0; z-index:40;
    padding:14px 10px 22px;
    background:linear-gradient(180deg, rgba(15,16,19,0) 0%, rgba(15,16,19,.85) 40%, rgba(15,16,19,1) 100%);
    border-top:1px solid #1d1f25; backdrop-filter:saturate(1.1) blur(4px);
  }
  .ribbon{position:relative; height:calc(var(--card-h) + 20px);
    display:flex; align-items:flex-end; justify-content:center;
    touch-action:pan-x; overflow-x:auto; scrollbar-width:none; gap:0; user-select:none;
  }
  .ribbon::-webkit-scrollbar{display:none}

  .card{
    position:relative; width:var(--card-w); height:var(--card-h);
    border-radius:var(--card-radius); overflow:hidden;
    background:#13161d; border:1px solid #2a2f3a; box-shadow:0 6px 18px rgba(0,0,0,.35);
    transform-origin:bottom center;
    transition:transform var(--transition), filter var(--transition), box-shadow var(--transition);
    outline:none; display:flex; flex-direction:column;
    -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
  }
  .card *{-webkit-user-select:none; user-select:none; -webkit-touch-callout:none;}
  body.no-select, body.no-select *{-webkit-user-select:none!important; user-select:none!important;}

  .card-header{
    padding:8px 10px 6px; font-size:12px; font-weight:800; letter-spacing:.02em;
    background:linear-gradient(180deg,#242a36,#1b202a); border-bottom:1px solid #2b3140;
    color:#7aa2ff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }
  .card-art{position:relative; flex:1; background:#0f1217; display:grid; place-items:center;}
  .card-art img{width:100%; height:100%; object-fit:cover; display:block; filter:saturate(1.05) contrast(1.02);}
  .card-art .fallback{font-size:12px; opacity:.7; padding:6px; text-align:center;}
  .card-footer{padding:8px 10px; font-size:11px; opacity:.85; border-top:1px solid #232836; background:#151821; line-height:1.35;}

  .card.is-focused{transform:translateY(calc(-1*var(--fan-lift))) scale(1.04) translateX(var(--dx,0px)); z-index:5; filter:saturate(1.06);}
  .card.is-left,.card.is-right{z-index:4; transform:translateY(-8px) translateX(var(--dx,0px));}
  @media (hover:hover){ .card:hover{filter:brightness(1.06);} }
  .card:focus-visible{ box-shadow:0 0 0 2px #7aa2ff, 0 6px 18px rgba(0,0,0,.35); }

  /* Preview (non-interactive so it never blocks drags) */
  .preview{
    position:absolute; left:50%; bottom:calc(100% + 12px);
    min-width:min(540px,92vw); max-width:92vw;
    padding:12px 14px; border-radius:12px; background:#12141a; border:1px solid #2a2f3a;
    box-shadow:0 12px 28px rgba(0,0,0,.45);
    display:none; z-index:50; pointer-events:none;
  }
  .preview.visible{display:block;}
  .preview h3{margin:0 0 6px; font-size:14px; font-weight:800;}
  .preview p{margin:0; font-size:12px; line-height:1.4; opacity:.9;}
</style>
</head>
<body>
  <!-- ===== Your existing header/board ===== -->
  <header><h1>The Grey</h1></header>

  <main class="board">
    <!-- Keep your real board markup. Slots here are just examples -->
    <section class="slots" id="slots">
      <div class="slot" data-slot="1"><p>Slot 1</p></div>
      <div class="slot" data-slot="2"><p>Slot 2</p></div>
      <div class="slot" data-slot="3"><p>Slot 3</p></div>
    </section>
  </main>

  <!-- ===== Ribbon layer ===== -->
  <section class="ribbon-wrap" aria-label="Your hand">
    <div class="preview" id="preview" role="dialog" aria-live="polite" aria-label="Card Preview"></div>
    <div class="ribbon" id="ribbon" aria-label="Card ribbon" tabindex="-1"></div>
  </section>

<script>
/* ========= RibbonHand: Vanilla, framework-free ========= */
(function(){
  const ribbon = document.getElementById('ribbon');
  const preview = document.getElementById('preview');
  const slots = Array.from(document.querySelectorAll('.slot'));

  let cards = [];                 // DOM buttons
  let handData = [];              // from Game.getHand()
  let focusIndex = -1;
  let baseOverlap = -90;
  let isPointerDown = false;
  let isDragging = false;
  let dragGhost = null;
  let dragFromIndex = -1;
  let longPressTimer = null;

  /* ---- Data bridge to your game ---- */
  const Game = window.Game || {};
  const getHand = () => (Game.getHand ? Game.getHand() : []);
  const playCard = (id, slotId) => { if (Game.playCard) Game.playCard(id, slotId); };

  function slugify(str){ return (str||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,''); }
  function resolveArt(card){
    // CHANGE THIS ROOT PATH if your art lives elsewhere:
    const root = 'assets/art/standard/';
    const key = card.artKey || slugify(card.name);
    return root + key + '.jpg';
  }

  /* ---- Render hand from game state ---- */
  function renderHand(){
    ribbon.innerHTML = '';
    handData = getHand();

    handData.forEach((card, i) => {
      const btn = document.createElement('button');
      btn.className = 'card';
      btn.type = 'button';
      btn.setAttribute('data-id', card.id);

      const head = document.createElement('div');
      head.className = 'card-header';
      head.textContent = card.name;

      const artWrap = document.createElement('div');
      artWrap.className = 'card-art';
      const img = document.createElement('img');
      img.alt = card.name + ' artwork';
      img.loading = 'lazy';
      img.src = resolveArt(card);
      const fb = document.createElement('div');
      fb.className = 'fallback';
      fb.textContent = (card.element ? (card.element + ' • ') : '') + (card.cost != null ? ('Cost ' + card.cost) : '');
      artWrap.appendChild(img);
      artWrap.appendChild(fb);
      img.addEventListener('load', () => { fb.style.display='none'; });
      img.addEventListener('error', () => { fb.style.display='grid'; img.style.display='none'; });

      const foot = document.createElement('div');
      foot.className = 'card-footer';
      foot.textContent = card.text || '';

      btn.appendChild(head);
      btn.appendChild(artWrap);
      btn.appendChild(foot);
      ribbon.appendChild(btn);
    });

    cards = Array.from(ribbon.querySelectorAll('.card'));
    attachCardHandlers();
    layoutStack();
    focusIndex = -1;
    applyFan();
    hidePreview();
  }

  /* ---- Layout / fan ---- */
  function layoutStack(){
    const n = cards.length;
    const minOverlap = -40, maxOverlap = -92;
    const t = Math.min(1, Math.max(0, (n - 4) / 8));
    baseOverlap = Math.round(maxOverlap + (minOverlap - maxOverlap) * Math.max(0, 1 - t));

    const cardW = 140;
    const totalWidth = (n>0) ? ((n-1)*(-baseOverlap) + cardW) : 0;
    const startX = Math.max(10, (ribbon.clientWidth - totalWidth) / 2);

    cards.forEach((card, i) => {
      const x = startX + i * (-baseOverlap);
      card.style.transform = `translateX(${x}px)`;
      card.style.setProperty('--dx','0px');
      card.style.zIndex = i + 1;
      card.dataset.index = i;
    });
  }
  function getSpread(){
    const base = 36;
    const scale = Math.max(0.8, Math.min(1.2, (Math.abs(baseOverlap) / 80)));
    return Math.round(base * scale);
  }
  function applyFan(){
    cards.forEach((card, i) => {
      const d = i - focusIndex;
      card.classList.remove('is-focused','is-left','is-right');
      if (focusIndex < 0){ card.style.setProperty('--dx','0px'); return; }
      if (d === 0){ card.classList.add('is-focused'); card.style.setProperty('--dx','0px'); }
      else if (d === -1 || d === -2){ card.classList.add('is-left');  card.style.setProperty('--dx', `${-Math.abs((3-Math.abs(d))*getSpread())}px`); }
      else if (d === 1  || d === 2 ){ card.classList.add('is-right'); card.style.setProperty('--dx', `${(3-Math.abs(d))*getSpread()}px`); }
      else { card.style.setProperty('--dx','0px'); }
    });
  }

  /* ---- Preview ---- */
  function showPreview(i){
    if (i < 0 || i >= cards.length){ hidePreview(); return; }
    const card = handData[i];
    preview.innerHTML = `<h3>${card.name}</h3><p>${card.text || ''}</p>`;
    preview.classList.add('visible');

    const cardRect = cards[i].getBoundingClientRect();
    const ribRect = ribbon.getBoundingClientRect();
    const centerX = cardRect.left + cardRect.width/2;
    const left = Math.min(ribRect.right-16, Math.max(ribRect.left+16, centerX));
    const offset = left - (ribRect.left + ribRect.width/2);
    preview.style.transform = `translateX(calc(-50% + ${offset}px))`;
  }
  function hidePreview(){ preview.classList.remove('visible'); }

  /* ---- Drag ghost & cleanup (fixes “floating card” forever) ---- */
  function startGhost(cardEl, i, e){
    dragGhost = cardEl.cloneNode(true);
    Object.assign(dragGhost.style, {
      position:'fixed', left:'0px', top:'0px',
      transform:'translate(-50%,-50%) scale(1.02)',
      pointerEvents:'none', opacity:.95, zIndex:999,
      boxShadow:'0 12px 28px rgba(0,0,0,.45)'
    });
    document.body.appendChild(dragGhost);
    positionGhost(e.clientX, e.clientY);
    slots.forEach(s => s.classList.add('is-dragging'));
  }
  function positionGhost(x,y){ if (dragGhost){ dragGhost.style.left = x+'px'; dragGhost.style.top = y+'px'; } }
  function updateDropTargets(x,y){
    const el = document.elementFromPoint(x,y);
    slots.forEach(s => s.classList.toggle('is-hot', s === el || (el && s.contains(el))));
  }
  function finishGhost(x,y, i){
    const el = document.elementFromPoint(x,y);
    const hot = slots.find(s => s === el || (el && s.contains(el)));
    if (hot){
      const slotId = hot.getAttribute('data-slot');
      const cardId = handData[i]?.id;
      if (cardId != null) playCard(cardId, slotId);
    }
    cleanupGhost();
  }
  function cleanupGhost(){
    if (dragGhost && dragGhost.parentNode) dragGhost.parentNode.removeChild(dragGhost);
    dragGhost = null;
    isDragging = false;
    isPointerDown = false;
    dragFromIndex = -1;
    document.body.classList.remove('no-select');
    hidePreview();
    slots.forEach(s => s.classList.remove('is-hot','is-dragging'));
  }

  /* ---- Interaction wiring ---- */
  function attachCardHandlers(){
    // Prevent native drags & text selection
    cards.forEach(c => c.addEventListener('dragstart', e => e.preventDefault()));
    document.addEventListener('selectstart', e => { if (isDragging || isPointerDown) e.preventDefault(); });

    // Hover preview (desktop)
    if (matchMedia('(hover: hover)').matches){
      cards.forEach((card, i) => {
        card.addEventListener('mouseenter', () => { focusIndex=i; applyFan(); showPreview(i); });
      });
      ribbon.addEventListener('mouseleave', () => { focusIndex=-1; applyFan(); hidePreview(); });
    }

    // Per-card pointer
    cards.forEach((card, i) => {
      // Click = select (no preview to avoid blocking drag)
      card.addEventListener('click', (e) => { if (isDragging) { e.preventDefault(); return; } focusIndex=i; applyFan(); });

      // Keyboard accessibility keeps preview
      card.addEventListener('focus', () => { focusIndex=i; applyFan(); showPreview(i); });
      card.addEventListener('blur',  () => { setTimeout(()=>{ if (!ribbon.contains(document.activeElement)) { focusIndex=-1; applyFan(); hidePreview(); }}, 0); });

      card.addEventListener('pointerdown', (e) => {
        isPointerDown = true; isDragging = false; dragFromIndex = i;
        document.body.classList.add('no-select');
        card.setPointerCapture(e.pointerId);
        clearTimeout(longPressTimer);
        longPressTimer = setTimeout(() => { if (!isDragging) { focusIndex=i; applyFan(); showPreview(i); } }, 350);
        e.preventDefault();
      });

      card.addEventListener('pointermove', (e) => {
        if (!isPointerDown || dragFromIndex !== i) return;
        const movedEnough = Math.hypot(e.movementX, e.movementY) > 6;
        if (movedEnough && !isDragging){
          isDragging = true;
          clearTimeout(longPressTimer);
          hidePreview();
          startGhost(card, i, e);
        }
        if (isDragging){
          positionGhost(e.clientX, e.clientY);
          updateDropTargets(e.clientX, e.clientY);
        }
      });

      card.addEventListener('pointerup', (e) => {
        clearTimeout(longPressTimer);
        if (isDragging) finishGhost(e.clientX, e.clientY, i);
        else cleanupGhost(); // ensure no “floating” residues
      });

      card.addEventListener('pointercancel', cleanupGhost);
    });

    // Global failsafes
    window.addEventListener('pointerup', () => { if (isPointerDown) cleanupGhost(); }, {passive:true});
    window.addEventListener('pointercancel', cleanupGhost, {passive:true});
    window.addEventListener('blur', cleanupGhost);
    document.addEventListener('visibilitychange', () => { if (document.hidden) cleanupGhost(); });

    // Responsive
    window.addEventListener('resize', () => {
      layoutStack();
      if (focusIndex >= 0 && preview.classList.contains('visible')) showPreview(focusIndex);
    });
  }

  /* ---- Slot click-to-play support (optional) ---- */
  slots.forEach(s => s.addEventListener('click', () => {
    // No-op here; your board likely already handles this
  }));

  /* ---- Boot ---- */
  renderHand();
  if (window.Game && typeof window.Game.onHandChanged === 'function'){
    window.Game.onHandChanged(renderHand);
  }
})();
</script>

<!-- ===== Your existing game bundles/scripts should remain included below this line =====
<script src="build/game.bundle.js"></script>
… etc.
-->
</body>
</html>
