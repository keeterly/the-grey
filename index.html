<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>The Grey — Arena Layout</title>
<meta name="theme-color" content="#0b0d10" />
<style>
:root{
  --bg:#0b0d10; --panel:#0f141c; --ink:#efece7; --muted:#b9b4ac; --line:#223044;
  --accent:#d7b77a; --slot:#0c1118; --slotLine:#33465d;
  --whiteA:#a9d0ff; --grayA:#a3a7b3; --blackA:#e9a8a8;
}
*{box-sizing:border-box}
html,body{margin:0;background:#0b0d10;color:var(--ink);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;-webkit-tap-highlight-color:transparent}
.wrap{max-width:1200px;margin:0 auto;padding:8px 10px 12px}

/* HUD */
.hud{display:flex;gap:8px;flex-wrap:wrap;align-items:center;background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:8px;margin-bottom:8px}
.pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#121721;border:1px solid #223044;font-size:12px}
button,select{background:linear-gradient(180deg,#17202b,#0e141d);color:var(--ink);border:1px solid var(--line);border-radius:12px;padding:8px 12px;font-size:14px;touch-action:manipulation}
button:disabled{opacity:.6}

/* ARENA BOARD GRID */
.board{display:grid;grid-template-columns:200px 1fr 260px;gap:10px;align-items:stretch}
@media (max-width:900px){ .board{grid-template-columns:1fr;grid-auto-rows:auto} }

.panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:10px;min-height:160px}
.panel h3{margin:0 0 6px 0;font-size:14px;color:#cfd6e1;letter-spacing:.04em}

/* Aetherflow (left column) */
.costs{display:grid;grid-template-columns:repeat(5,1fr);gap:4px;margin-bottom:6px}
.cost{text-align:center;font-weight:900;padding:6px 0;background:#0b111a;border:1px solid #213145;border-radius:8px;color:var(--accent)}
.market{display:grid;grid-template-columns:1fr;gap:8px;max-height:540px;overflow:auto}
.card{position:relative;background:#111621;border:1px solid #23344a;border-radius:12px;padding:8px}
.card.white{border-image:linear-gradient(180deg,var(--whiteA),#6fa4ff) 1}
.card.gray{ border-image:linear-gradient(180deg,var(--grayA),#6b7280) 1}
.card.black{border-image:linear-gradient(180deg,var(--blackA),#b56565) 1}
.card .name{font-weight:800;color:var(--accent);margin:.25rem 0}
.tag{font-size:10px;padding:2px 6px;border-radius:6px;border:1px solid #2d3f56;background:#0b111a;margin-right:4px}
.smallmuted{font-size:12px;color:var(--muted)}
.art{height:60px;border-radius:8px;margin:6px 0 8px;background:linear-gradient(180deg,#0f1520,#0a0f16);border:1px solid #223044}
@media (max-width:900px){ .market{max-height:none} }

/* Battlefield (middle column) */
.battle{display:flex;flex-direction:column;gap:8px}
.rowSlots{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.slot{background:var(--slot);border:2px dashed var(--slotLine);border-radius:12px;min-height:120px;padding:8px}
.slot .cap{font-size:12px;color:var(--muted);margin-bottom:6px}
.slot.hot{border-color:#86b7ff;box-shadow:0 0 0 3px rgba(134,183,255,.2) inset}
.inlineCard .card{min-width:auto;max-width:none;padding:8px}
.inlineCard .art{height:46px}
.glyphs{display:flex;gap:6px;flex-wrap:wrap}
.glyph{height:12px;width:84px;background:linear-gradient(90deg,#0b111a,#131a27);border:1px solid #2d3f56;border-radius:8px}

/* Log (right column) */
.log{height:100%;min-height:260px;max-height:560px;overflow:auto;background:#0b111a;border:1px solid #1c2a3a;border-radius:10px;padding:8px;font-size:12px}

/* Hand at bottom */
.handBox{margin-top:10px;background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:8px}
.fan{position:relative;height:220px;border:1px dashed #263445;border-radius:12px;background:linear-gradient(180deg,#0b1114,#0a0f15)}
.hand{position:absolute;left:50%;bottom:6px;transform:translateX(-50%);height:210px;pointer-events:none}
.hc{position:absolute;bottom:0;left:50%;transform-origin:50% 120%;transition:transform .12s ease, filter .12s ease;pointer-events:auto}
.hc .card{width:170px}
.hc[data-raise="1"]{transform:translate(-50%, -12px) scale(1.03);z-index:5;filter:drop-shadow(0 10px 16px rgba(0,0,0,.4))}
.hand-actions{display:none;gap:6px;flex-wrap:wrap;margin-top:6px}
.hc[data-raise="1"] .hand-actions{display:flex}

/* Tiny helpers */
.small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">

  <div class="hud">
    <span class="pill">You ♥ <b id="hp">5</b></span>
    <span class="pill">AI ♥ <b id="aiHp">5</b></span>
    <span class="pill">⚡ <b id="ae">0</b></span>
    <span class="pill">Deck <b id="deck">0</b></span>
    <span class="pill">Discard <b id="disc">0</b></span>
    <span class="pill">Glyphs <b id="glyphs">0</b></span>
    <span class="pill" id="turnTag">Turn 1</span>
    <span style="flex:1"></span>
    <b class="small">Spellweaver:</b>&nbsp;<select id="swSelect"></select>
    <button id="drawBtn">Draw</button>
    <button id="endBtn">End Turn</button>
    <button id="resetBtn">Reset</button>
  </div>

  <div class="board">
    <!-- Left: Aetherflow -->
    <div class="panel">
      <h3>Aetherflow</h3>
      <div class="costs" id="mCosts"></div>
      <div class="market" id="mRow"></div>
    </div>

    <!-- Middle: Battlefield (Arena-style: opponent row on top, your row below) -->
    <div class="panel battle">
      <div>
        <div class="small" style="opacity:.8">Opponent</div>
        <div class="rowSlots" id="aiSlots"></div>
      </div>
      <div>
        <div class="small" style="opacity:.8">You</div>
        <div class="rowSlots" id="slots"></div>
        <div class="glyphs" id="glyphView"></div>
      </div>
    </div>

    <!-- Right: Log -->
    <div class="panel">
      <h3>Log</h3>
      <div class="log" id="log"></div>
    </div>
  </div>

  <!-- Bottom: Hand -->
  <div class="handBox">
    <div class="small">Your Hand</div>
    <div class="fan"><div class="hand" id="hand"></div></div>
  </div>

</div>

<script>
document.addEventListener('touchstart',()=>{}, {passive:true});
function bindTap(el,fn){ el.addEventListener('click',fn); el.addEventListener('touchend',e=>{ e.preventDefault(); fn(e); }, {passive:false}); }

/* Spellweavers (same as prior) */
const SPELLWEAVERS = {
  "Seraya (Wardsinger)": { desc:"Trance at 3♥: prevent 1 dmg/round • at 1♥: +1⚡ when your glyph flips",
    trance:[{hp:3,apply:s=>{s.flags.preventOnce=true;s.flags.preventAvailable=true;},label:"Ward online."},
            {hp:1,apply:s=>{s.flags.glyphAether=true;},label:"+1⚡ on glyph flip."}]},
  "Thalorin (Chronomancer)": { desc:"Trance at 4♥: once/turn free +1 advance • at 2♥: copy your Instants",
    trance:[{hp:4,apply:s=>{s.flags.hasChrono=true;s.flags.chronoUsed=false;},label:"Chrono Step."},
            {hp:2,apply:s=>{s.flags.copyInst=true;},label:"Instant Echo."}]},
  "Kaelis (Aether Savant)": { desc:"Trance at 2♥: leftmost Flow -1 • at 1♥: free channel on buy",
    trance:[{hp:2,apply:s=>{s.flags.leftDiscount=true;},label:"Leftmost Flow -1⚡."},
            {hp:1,apply:s=>{s.flags.freeChannelOnBuy=true;},label:"Free channel on buy."}]},
  "Zarik (Trickster)": { desc:"Trance at 3♥: once/turn Gamble • at 1♥: chance to deflect (not sim)",
    trance:[{hp:3,apply:s=>{s.flags.trickOnce=true;s.flags.trickUsed=false;},label:"Gamble unlocked."},
            {hp:1,apply:s=>{s.flags.trickCancel=true;},label:"Deflect (future)."}]}
};

/* Base deck & Flow */
const BASE=[
  {n:"Spark",t:"Instant",c:"black",v:1,txt:"Deal 1 dmg.",eff:"spark"},
  {n:"Spark",t:"Instant",c:"black",v:1,txt:"Deal 1 dmg.",eff:"spark"},
  {n:"Shield Flicker",t:"Instant",c:"white",v:1,txt:"Prevent 1 dmg this round.",eff:"shield"},
  {n:"Channel Spark",t:"Utility",c:"gray",v:0,txt:"Self-discard: +1⚡.",eff:"chan_self"},
  {n:"Minor Hex",t:"Spell",c:"gray",v:1,p:2,txt:"After 2: foe discards 1 and loses 1⚡.",eff:"hex_plus"},
  {n:"Emberbolt",t:"Spell",c:"black",v:1,p:3,txt:"After 3: deal 2 dmg.",eff:"ember"}
];
const FLOW=[
  {n:"Accelerate",t:"Instant",c:"white",v:1,txt:"Advance one of your spells +1.",eff:"accel"},
  {n:"Temporal Loop",t:"Spell",c:"white",v:2,p:2,txt:"After 2: replay your last Instant (or draw).",eff:"loop",rar:"Legendary"},
  {n:"Chrono Barrier",t:"Glyph",c:"white",v:1,txt:"When targeted: negate spell/dmg.",eff:"g_barrier"},
  {n:"Meditate",t:"Instant",c:"gray",v:0,txt:"Gain 1⚡ and draw 1.",eff:"med"},
  {n:"Phase Swap",t:"Spell",c:"gray",v:1,p:2,txt:"After 2: swap two of your spells.",eff:"swap"},
  {n:"Stonewall",t:"Spell",c:"gray",v:1,p:2,txt:"After 2: opponent’s next Advance costs +1⚡.",eff:"tax"},
  {n:"Mirror Ward",t:"Glyph",c:"gray",v:1,txt:"When you’d take dmg: reflect it.",eff:"g_mirror"},
  {n:"Dark Bargain",t:"Spell",c:"black",v:2,p:3,txt:"After 3: deal 3 dmg; you lose 2♥.",eff:"bargain",rar:"Legendary"},
  {n:"Venom Dart",t:"Instant",c:"black",v:1,txt:"Deal 1 dmg & foe discards 1.",eff:"venom"},
  {n:"Seal of Binding",t:"Glyph",c:"black",v:1,txt:"On enemy spell play: cancel & block that slot until their next turn.",eff:"g_bind"},
  {n:"Null Pulse",t:"Instant",c:"white",v:1,txt:"Counter: cancel a resolving spell.",eff:"counter"}
];

/* State */
let S={};
function uid(){return Math.random().toString(36).slice(2,9)}
function shuf(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
function makeDeck(){return shuf(BASE.map(x=>Object.assign({id:uid()},x)))}
function makeFlow(){return shuf(FLOW.map(x=>Object.assign({id:uid()},x)))}
function log(m){const el=document.getElementById('log');const t=new Date().toLocaleTimeString();el.innerHTML+=`<div><span style="color:#9ab">${t}</span> — ${m}</div>`;el.scrollTop=el.scrollHeight}

/* Core */
function reset(swName){
  const name=swName||document.getElementById('swSelect').value||Object.keys(SPELLWEAVERS)[0];
  S={sw:name,hp:5,ae:0,deck:makeDeck(),hand:[],disc:[],slots:[null,null,null],glyphs:[],
     ai:{hp:5,ae:0,deck:makeDeck(),hand:[],disc:[],slots:[null,null,null],glyphs:[],lastInstant:null,taxes:0,blockedSlots:[]},
     flowDeck:makeFlow(),flowRow:[null,null,null,null,null],
     flags:{preventOnce:false,preventAvailable:false,glyphAether:false,hasChrono:false,copyInst:false,leftDiscount:false,freeChannelOnBuy:false,trickOnce:false,trickUsed:false},
     lastInstant:null,turn:1,tranceHit:{},taxes:0,blockedSlots:[]};
  for(let i=0;i<5;i++){draw();aiDraw()}
  slideFlow(true); render(); log(`New game — Spellweaver: ${S.sw}.`)}

/* Draw/Play/Channel */
function draw(){ if(!S.deck.length){ if(!S.disc.length){log("No cards to draw.");return} S.deck=shuf(S.disc);S.disc=[];log("You reshuffle.") } S.hand.push(S.deck.pop()); render() }
function channelSelf(handIdx){const c=S.hand.splice(handIdx,1)[0];S.ae+=1;S.disc.push(c);log(`Channel Spark (+1⚡)`);render()}
function channel(handIdx){const c=S.hand.splice(handIdx,1)[0];const g=c.v||0;S.ae+=g;S.disc.push(c);log(`Channel ${c.n} (+${g}⚡)`);render()}
function playFromHand(handIdx){
  const c=S.hand.splice(handIdx,1)[0];
  if(c.t==="Spell"){
    const s=S.slots.findIndex((x,i)=>!x&&!S.blockedSlots.includes(i));
    if(s<0){log("No available slot (or blocked).");S.hand.push(c);render();return}
    S.slots[s]={c,ph:1,advUsed:false}; log(`You play ${c.n} to Slot ${s+1}.`);
  }else if(c.t==="Glyph"){S.glyphs.push(c);log("You set a Glyph face-down.")}
  else{runInstant("you",c);S.disc.push(c);if(S.flags.copyInst){log("Instant Echo: repeats.");runInstant("you",c)};S.lastInstant=c}
  render();
}

/* Advance rule (no auto-tick; once/turn per spell) */
function advance(i){
  const s=S.slots[i]; if(!s) return;
  const cost=1+(S.taxes||0); if(s.advUsed){log("That spell already advanced this turn.");return}
  if(S.ae<cost){log(`Need ${cost}⚡ to advance.`);return}
  S.ae-=cost; s.ph+=1; s.advUsed=true;
  if(s.ph>=(s.c.p||99)) resolvePlayer(i);
  if(S.taxes>0) S.taxes=0;
  render();
}

/* Effects */
function runInstant(who,c){
  switch(c.eff){
    case "spark": (who==="you")?damageAI(1):damageYou(1); break;
    case "shield": if(who==="you"){S.flags.preventAvailable=true;log("Shield Flicker: prevent 1 this round.");} break;
    case "chan_self": if(who==="you"){S.ae+=1;log("+1⚡ (Channel Spark).")}break;
    case "accel":
      if(who==="you"){const idx=S.slots.findIndex(s=>s&&!s.advUsed); if(idx<0){log("No eligible spell.");break}
        S.slots[idx].ph=Math.min(S.slots[idx].c.p,S.slots[idx].ph+1);S.slots[idx].advUsed=true;log("Accelerate: +1 phase."); if(S.slots[idx].ph===S.slots[idx].c.p) resolvePlayer(idx);}
      break;
    case "med": if(who==="you"){S.ae+=1;draw();log("Meditate: +1⚡ & draw 1.")} else {S.ai.ae+=1;aiDraw();log("AI meditates.")} break;
    case "venom": (who==="you")?(damageAI(1),log("AI discards 1 (sim).")):(damageYou(1),log("You discard 1 (sim).")); break;
    case "counter": log((who==="you")?"Null Pulse readied.":"AI holds a counter."); break;
  }
}
function runResolve(who,c){
  switch(c.eff){
    case "hex_plus":
      if(who==="you"){ if(consumeBarrier(S.ai)) break; log("Minor Hex+: AI discards 1 and loses 1⚡ (sim)."); S.ai.ae=Math.max(0,S.ai.ae-1); }
      else { if(consumeBarrier(S)) break; log("AI Hex+: you discard 1 and lose 1⚡ (sim)."); S.ae=Math.max(0,S.ae-1); }
      break;
    case "ember": (who==="you")?damageAI(2):damageYou(2); break;
    case "swap": log(who==="you"?"Phase Swap (abstract).":"AI swaps (no-op)."); break;
    case "loop": if(who==="you"){ if(S.lastInstant){ log(`Temporal Loop replays ${S.lastInstant.n}.`); runInstant("you",S.lastInstant);} else {draw();log("Loop draws 1 (no instant).")} } break;
    case "tax": if(who==="you"){S.ai.taxes=(S.ai.taxes||0)+1;log("Stonewall: AI next advance +1⚡.")} else {S.taxes=(S.taxes||0)+1;log("AI Stonewall: your next advance +1⚡.")} break;
    case "bargain": if(who==="you"){damageAI(3);S.hp=Math.max(0,S.hp-2);log("Dark Bargain recoil: -2♥")} else {damageYou(3);S.ai.hp=Math.max(0,S.ai.hp-2);log("AI recoil -2♥")} break;
  }
}
function consumeBarrier(target){
  const i=target.glyphs.findIndex(g=>g.eff==="g_barrier");
  if(i>-1){ target.glyphs.splice(i,1); log(target===S?"Your Chrono Barrier negates it.":"AI's Chrono Barrier negates it."); return true; }
  return false;
}

/* Damage/Trance */
function damageYou(n){
  const m=S.glyphs.findIndex(g=>g.eff==="g_mirror");
  if(m>-1&&n>0){S.glyphs.splice(m,1);log("Mirror Ward reflects!"); if(S.flags.glyphAether){S.ae+=1;log("+1⚡ (glyph flip).")} damageAI(n); return}
  if(consumeBarrier(S)){ if(S.flags.glyphAether){S.ae+=1;log("+1⚡ (glyph flip).")} return}
  let d=n; if(S.flags.preventAvailable){ d=Math.max(0,d-1); S.flags.preventAvailable=false; log("Ward prevents 1.")}
  if(d>0){S.hp=Math.max(0,S.hp-d);log(`You take ${d} damage.`); applyTranceIfEligible()}
}
function damageAI(n){
  const m=S.ai.glyphs.findIndex(g=>g.eff==="g_mirror");
  if(m>-1&&n>0){S.ai.glyphs.splice(m,1);log("AI Mirror Ward reflects!"); damageYou(n); return}
  if(consumeBarrier(S.ai)) return;
  S.ai.hp=Math.max(0,S.ai.hp-n); log(`AI takes ${n} damage.`);
}
function applyTranceIfEligible(){
  const spec=SPELLWEAVERS[S.sw]; let fired=[];
  spec.trance.forEach(step=>{ if(S.hp<=step.hp && !S.tranceHit[step.hp]){ step.apply(S); S.tranceHit[step.hp]=true; fired.push(`${step.hp}♥: ${step.label}`) } });
  if(fired.length){ log(`Trance — ${fired.join(" ")}`) }
  if(S.flags.preventOnce) S.flags.preventAvailable=true;
  render();
}

/* Aetherflow */
function flowCostAt(i){ const band=[4,3,2,2,2]; let cost=band[i]; if(i===0 && S.flags.leftDiscount) cost=Math.max(1,cost-1); return cost; }
function slideFlow(initial=false){ S.flowRow=[null,...S.flowRow.slice(0,4)]; const next=S.flowDeck.pop(); S.flowRow[0]=next||null; if(!initial) render(); }
function buy(i){
  const card=S.flowRow[i]; if(!card){ log("Empty."); return; }
  const cost=flowCostAt(i); if(S.ae<cost){ log("Not enough ⚡."); return; }
  S.ae-=cost;
  if(card.t==="Glyph"){ S.glyphs.push(card); log(`You learn ${card.n} and set it.`); }
  else { S.disc.push(card); log(`You learn ${card.n}; it will shuffle in.`); }
  S.flowRow[i]=null; render();
}

/* AI */
function aiDraw(){ if(!S.ai.deck.length){ if(S.ai.disc.length){ S.ai.deck=shuf(S.ai.disc); S.ai.disc=[]; log("AI reshuffles."); } else return; } S.ai.hand.push(S.ai.deck.pop()); }
function aiTurn(){
  log("— AI Turn —"); aiDraw();
  const gIdx=S.ai.hand.findIndex(c=>c.t==="Glyph");
  if(gIdx>-1 && Math.random()<0.6){ const g=S.ai.hand.splice(gIdx,1)[0]; S.ai.glyphs.push(g); log("AI sets a Glyph."); }
  const empty=S.ai.slots.findIndex(x=>!x);
  if(empty>-1){
    let idx=S.ai.hand.findIndex(c=>c.t==="Spell" && c.n==="Emberbolt");
    if(idx===-1) idx=S.ai.hand.findIndex(c=>c.t==="Spell");
    if(idx>-1){ const card=S.ai.hand.splice(idx,1)[0]; S.ai.slots[empty]={c:card,ph:1,advUsed:false}; log(`AI plays ${card.n}.`); }
  }
  const med=S.ai.hand.findIndex(c=>c.eff==="med"); if(med>-1 && Math.random()<0.6){ const c=S.ai.hand.splice(med,1)[0]; runInstant("ai",c); S.ai.disc.push(c); }
  const sp=S.ai.hand.findIndex(c=>c.eff==="spark"); if(sp>-1 && Math.random()<0.33){ const c=S.ai.hand.splice(sp,1)[0]; runInstant("ai",c); S.ai.disc.push(c); }
  const act=S.ai.slots.findIndex(s=>s && !s.advUsed);
  if(act>-1){ if(S.ai.ae>=1+(S.ai.taxes||0)){ S.ai.ae-=1+(S.ai.taxes||0); S.ai.slots[act].ph+=1; S.ai.slots[act].advUsed=true; if(S.ai.taxes>0) S.ai.taxes=0; if(S.ai.slots[act].ph>=S.ai.slots[act].c.p) aiResolve(act); log("AI advances a spell."); } }
  for(let i=4;i>=0;i--){ const c=S.flowRow[i]; const cost=flowCostAt(i); if(c && cost<=S.ai.ae){ S.ai.ae-=cost; if(c.t==="Glyph"){ S.ai.glyphs.push(c);} else { S.ai.disc.push(c);} S.flowRow[i]=null; log("AI learns a card."); break; } }
  S.ai.slots.forEach(s=>{ if(s) s.advUsed=false; });
  render(); log("AI ends turn.");
}
function aiResolve(i){ const s=S.ai.slots[i]; if(!s) return; runResolve("ai",s.c); S.ai.disc.push(s.c); S.ai.slots[i]=null; }

/* Turn flow */
function endTurn(){
  if(S.flags.preventOnce) S.flags.preventAvailable=true;
  S.slots.forEach(s=>{ if(s) s.advUsed=false; });
  slideFlow(); S.turn+=1; render(); log("You end your turn."); setTimeout(aiTurn, 320);
}

/* UI helpers */
function schoolFrame(){return `<svg viewBox='0 0 100 140' class='frame' style='position:absolute;inset:6px;opacity:.6' preserveAspectRatio='none'>
<g fill='none' stroke-width='1.2'><path d='M3 18 L3 6 L18 6'/><path d='M82 6 L97 6 L97 18'/><path d='M3 122 L3 134 L18 134'/><path d='M82 134 L97 134 L97 122'/><circle cx='50' cy='10' r='3'/><circle cx='50' cy='130' r='3'/></g></svg>`}
function tagRow(c){return `<span class='tag ${c.c}'>${c.c.toUpperCase()}</span><span class='tag'>${c.t}</span><span class='tag'>V${c.v||0}</span>`}

function render(){
  hp.textContent=S.hp; aiHp.textContent=S.ai.hp; ae.textContent=S.ae; deck.textContent=S.deck.length; disc.textContent=S.disc.length; glyphs.textContent=S.glyphs.length; turnTag.textContent=`Turn ${S.turn}`;
  const sel=document.getElementById('swSelect'); if(!sel.dataset.ready){ Object.keys(SPELLWEAVERS).forEach(k=>{const o=document.createElement('option');o.value=k;o.textContent=k;sel.appendChild(o)}); sel.dataset.ready=1; sel.value=S.sw; sel.addEventListener('change',()=>reset(sel.value)); } else sel.value=S.sw;

  // Aetherflow
  mCosts.innerHTML=""; [4,3,2,2,2].forEach((c,idx)=>{ let shown=c; if(idx===0 && S.flags.leftDiscount) shown=Math.max(1,c-1); const d=document.createElement('div'); d.className='cost'; d.textContent=shown; mCosts.appendChild(d) });
  mRow.innerHTML=""; S.flowRow.forEach((c,idx)=>{ const w=document.createElement('div'); w.className=`card ${c?c.c:''}`; if(!c){ w.innerHTML="<div class='smallmuted'>— empty —</div>"; mRow.appendChild(w); return; } w.innerHTML=`${schoolFrame()}<div>${tagRow(c)}</div><div class='art'></div><div class='name'>${c.n}</div><div class='smallmuted'>${c.txt}</div>`; const b=document.createElement('button'); b.textContent=`Learn (${flowCostAt(idx)}⚡)`; bindTap(b,()=>buy(idx)); w.appendChild(b); mRow.appendChild(w); });

  // Opponent slots
  aiSlots.innerHTML=""; S.ai.slots.forEach((s,i)=>{ const div=document.createElement('div'); div.className='slot inlineCard'; if(s){ div.innerHTML=`<div class='cap'>Slot ${i+1}</div><div class='card ${s.c.c}'>${schoolFrame()}<div class='art'></div><div class='name'>${s.c.n}</div><div class='smallmuted'>Phase ${s.ph}/${s.c.p}</div></div>`; } else { div.innerHTML=`<div class='cap'>Slot ${i+1}</div><div class='smallmuted'>Empty</div>`} aiSlots.appendChild(div) });

  // Your slots
  slots.innerHTML=""; S.slots.forEach((s,i)=>{ const div=document.createElement('div'); div.className='slot inlineCard'; if(s){ div.innerHTML=`<div class='cap'>Slot ${i+1}</div><div class='card ${s.c.c}'>${schoolFrame()}<div class='art'></div><div class='name'>${s.c.n}</div><div class='smallmuted'>Phase ${s.ph}/${s.c.p}</div></div>`; const b=document.createElement('button'); b.textContent=`Advance (1${S.taxes?`+${S.taxes}`:""}⚡)`; bindTap(b,()=>{ if(S.taxes>0) S.taxes=0; advance(i) }); b.disabled = s.advUsed; div.appendChild(b);} else { div.innerHTML=`<div class='cap'>Slot ${i+1}</div><div class='smallmuted'>Empty</div>`} slots.appendChild(div) });

  // Glyphs
  glyphView.innerHTML = S.glyphs.length ? S.glyphs.map(_=>'<div class="glyph"></div>').join('') : '<span class="small">No glyphs set.</span>';

  // Hand fan
  const handEl=document.getElementById('hand'); handEl.innerHTML="";
  const N=S.hand.length, arcDeg=Math.min(54, 13*(N-1));
  for(let i=0;i<N;i++){
    const holder=document.createElement('div'); holder.className='hc';
    const t=(N===1)?0:(i/(N-1)-0.5); const angle=t*arcDeg; const spread=(N>1)? (t*(N>5?260:200)) : 0;
    holder.style.transform=`translate(calc(-50% + ${spread}px), 0px) rotate(${angle}deg)`; holder.dataset.raise="0";
    const c=S.hand[i]; const card=document.createElement('div'); card.className=`card ${c.c}`;
    card.innerHTML=`${schoolFrame()}<div>${tagRow(c)}</div><div class='art'></div><div class='name'>${c.n}</div><div class='smallmuted'>${c.txt}</div>`;
    const actions=document.createElement('div'); actions.className='hand-actions';
    const p=document.createElement('button'); p.textContent=(c.t==="Spell"?"Play to Slot":(c.t==="Glyph"?"Set Glyph":"Play")); bindTap(p,()=>playFromHand(i));
    const ch=document.createElement('button'); ch.textContent = c.eff==="chan_self" ? "Channel (+1)" : `Channel (+${c.v||0})`; bindTap(ch,()=> c.eff==="chan_self"?channelSelf(i):channel(i));
    actions.appendChild(p); actions.appendChild(ch); card.appendChild(actions); holder.appendChild(card);
    bindTap(card, ()=>{ holder.dataset.raise = holder.dataset.raise==="1" ? "0":"1"; });
    enableDrag(card, i, holder);
    handEl.appendChild(holder);
  }
}
function setSpellweaver(name){ S.sw=name; S.tranceHit={}; applyTranceIfEligible(); render(); }

/* Drag for spells only */
function enableDrag(cardEl, handIdx, holder){
  let curX=0,curY=0,drag=false;
  function move(e){const t=e.touches?e.touches[0]:e; curX=t.clientX; curY=t.clientY; if(drag){ cardEl.style.position='fixed'; cardEl.style.left=(curX-90)+'px'; cardEl.style.top=(curY-120)+'px'; cardEl.style.zIndex=9999; highlight(curX,curY,true);}}
  function start(e){drag=true; holder.dataset.raise="1"; cardEl.style.pointerEvents='none'; document.addEventListener('touchmove',move,{passive:false}); document.addEventListener('mousemove',move); document.addEventListener('touchend',end,{passive:false}); document.addEventListener('mouseup',end);}
  function end(){ document.removeEventListener('touchmove',move); document.removeEventListener('mousemove',move); document.removeEventListener('touchend',end); document.removeEventListener('mouseup',end); cardEl.style.position=''; cardEl.style.left=''; cardEl.style.top=''; cardEl.style.pointerEvents=''; cardEl.style.zIndex=''; const target = highlight(curX,curY,false); if(target!=null){ const c=S.hand[handIdx]; if(c.t==="Spell"){ if(S.slots[target]){log("That slot is occupied."); render(); return;} S.hand.splice(handIdx,1); S.slots[target]={c,ph:1,advUsed:false}; log(`You play ${c.n} to Slot ${target+1}.`); render(); } } }
  function highlight(x,y,apply){ const els=[...document.querySelectorAll('#slots .slot')]; let target=null; els.forEach((el,idx)=>{ const r=el.getBoundingClientRect(); const inside=x>=r.left && x<=r.right && y>=r.top && y<=r.bottom; if(apply){ el.classList.toggle('hot', inside && !S.slots[idx]); } if(inside) target=idx; }); if(!apply){ els.forEach(el=>el.classList.remove('hot')); } return target; }
  cardEl.addEventListener('touchstart',start,{passive:false}); cardEl.addEventListener('mousedown',start);
}

/* Buttons */
bindTap(drawBtn, ()=>draw());
bindTap(endBtn,  ()=>endTurn());
bindTap(resetBtn,()=>reset(S.sw));

/* Resolve actions */
function resolvePlayer(i){ const s=S.slots[i]; if(!s) return; runResolve("you",s.c); S.disc.push(s.c); S.slots[i]=null; render(); }
function aiResolve(i){ const s=S.ai.slots[i]; if(!s) return; runResolve("ai",s.c); S.ai.disc.push(s.c); S.ai.slots[i]=null; }

/* Init */
(function init(){
  const sel=document.getElementById('swSelect');
  Object.keys(SPELLWEAVERS).forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; sel.appendChild(o); });
  sel.addEventListener('change', ()=> reset(sel.value));
  sel.value = Object.keys(SPELLWEAVERS)[0];
  reset(sel.value);
})();
</script>
</body>
</html>
