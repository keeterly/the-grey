<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>The Grey — Spellweavers (Mobile)</title>
<meta name="theme-color" content="#0b0d10">
<style>
:root{
  --bg:#0b0d10;--panel:#0e1218;--ink:#efece7;--muted:#b9b4ac;
  --line:#1e2631;--accent:#d7b77a;--chip:#121721;--chip-line:#223043;--slot:#0c1118;
  --card:#111621;--card-line:#23344a;--good:#78e08f;--bad:#ff7a7a;
  --whiteA:#a9d0ff;--whiteB:#6fa4ff;--grayA:#a3a7b3;--grayB:#6b7280;--blackA:#e9a8a8;--blackB:#b56565;
}
*{box-sizing:border-box;margin:0;padding:0}
body{background:var(--bg);color:var(--ink);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;min-height:100vh}
.wrap{padding:12px;max-width:1100px;margin:auto;overflow-x:hidden}
.banner{height:100px;border-radius:14px;margin-bottom:12px;position:relative;overflow:hidden;border:1px solid #202a38;background:linear-gradient(180deg,#151b26,#0e121a);box-shadow:0 8px 26px rgba(0,0,0,.35) inset,0 10px 30px rgba(0,0,0,.25)}
.banner .title{position:absolute;left:14px;top:12px;font-weight:900;letter-spacing:.14em;color:var(--accent)}
.banner .subtitle{position:absolute;left:14px;top:40px;font-size:12px;color:#9db3cc}
.banner svg.crest{position:absolute;right:10px;top:10px;opacity:.85}
.zone{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:10px;margin-bottom:10px;box-shadow:0 6px 18px rgba(0,0,0,.25) inset}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:var(--chip);border:1px solid var(--chip-line);font-size:12px;margin-right:4px}
.badge{border:1px solid #2b3a51;background:#0b111a;color:#a9d0ff;padding:2px 6px;border-radius:6px;font-size:11px;margin-left:4px}
button,select{background:linear-gradient(180deg,#151c27,#0e141d);color:var(--ink);border:1px solid var(--line);border-radius:12px;padding:8px 10px;font-size:14px;cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}
.hint{font-size:11px;color:#9ab;margin-top:6px}
.costRow{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:6px}
.costRow div{flex:1 0 60px;text-align:center;font-weight:700;padding:4px;border:1px solid #213145;border-radius:8px;background:#0b111a;color:var(--accent)}
.market{display:flex;flex-wrap:wrap;gap:8px;overflow-x:auto}
.card{background:var(--card);border:1px solid var(--card-line);border-radius:14px;padding:10px;min-width:180px;flex:1 0 180px;position:relative;box-shadow:0 6px 16px rgba(0,0,0,.28);margin-bottom:8px}
.card h4{font-size:14px;color:var(--accent);margin-bottom:4px}
.card p{font-size:12px;color:var(--muted);margin-bottom:4px}
.card .actions{display:flex;gap:6px;margin-top:6px}
.card .rarity{position:absolute;top:6px;right:8px;font-size:9px;padding:2px 4px;background:#0c0c0e;border:1px solid #3c3c3c;border-radius:6px;color:#d9d3c7}
.card.white{border-image:linear-gradient(180deg,var(--whiteA),var(--whiteB)) 1;box-shadow:0 4px 12px rgba(79,153,255,.15)}
.card.gray{border-image:linear-gradient(180deg,var(--grayA),var(--grayB)) 1;box-shadow:0 4px 12px rgba(160,160,170,.14)}
.card.black{border-image:linear-gradient(180deg,var(--blackA),var(--blackB)) 1;box-shadow:0 4px 12px rgba(214,104,104,.15)}
.slots{display:flex;gap:8px;flex-wrap:wrap}
.slot{flex:1 0 30%;background:var(--slot);border:2px dashed #33465d;border-radius:12px;padding:8px;min-height:140px;position:relative}
.slot h5{font-size:12px;color:var(--muted);margin-bottom:6px}
.handContainer{position:fixed;bottom:0;left:0;width:100%;background:linear-gradient(0deg,#0e1218,#151b26);padding:10px 0;box-shadow:0 -2px 10px rgba(0,0,0,.4)}
.hand{display:flex;justify-content:center;position:relative;gap:0}
.handCard{position:relative;transition:transform .2s,box-shadow .2s;cursor:pointer;margin:0 -50px}
.handCard:hover{transform:translateY(-10px) scale(1.05);box-shadow:0 8px 16px rgba(0,0,0,.5);z-index:5}
.dropdownSection{display:flex;flex-direction:column}
</style>
</head>
<body>
<div class="wrap">
  <div class="banner">
    <div class="title">THE GREY</div>
    <div class="subtitle">Spellweavers of Venia — Aether & Omen</div>
    <svg class="crest" viewBox="0 0 90 90"><g fill="none" stroke="#d7b77a" opacity=".85"><circle cx="45" cy="45" r="22"/><path d="M45 18 L58 40 L32 40 Z"/><circle cx="45" cy="45" r="6"/></g></svg>
  </div>

  <!-- HUD -->
  <div class="zone">
    <div class="row">
      <span class="pill">You ♥ <b id="hp">5</b></span>
      <span class="pill">AI ♥ <b id="aiHp">5</b></span>
      <span class="pill">⚡ <b id="ae">0</b></span>
      <span class="pill">Deck <b id="deckCount">0</b></span>
      <span class="pill">Discard <b id="discardCount">0</b></span>
      <span class="pill">Glyphs <b id="glyphCount">0</b></span>
      <span class="badge" id="turnTag">Turn 1</span>
    </div>
    <div class="row dropdownSection" style="margin-top:6px;">
      <label class="small">Spellweaver:</label>
      <select id="swSelect" style="width:100%"></select>
      <span id="swDesc" class="small" style="margin-top:4px"></span>
      <span id="tranceNote" class="small" style="margin-top:2px"></span>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="drawBtn">Draw</button>
      <button id="endBtn">End Turn</button>
      <button id="resetBtn">Reset</button>
      <button id="chronoBtn" disabled>Chrono</button>
      <button id="trickBtn" disabled>Gamble</button>
    </div>
    <div class="hint">Spells advance only when you press Advance (max once/turn per spell). Aetherflow purchases go into your discard and cycle into your deck.</div>
  </div>

  <!-- Aetherflow -->
  <div class="zone">
    <b>Aetherflow</b>
    <div class="costRow" id="flowCosts"></div>
    <div class="market" id="flowRow"></div>
  </div>

  <!-- Boards -->
  <div class="zone">
    <b>Your Board</b>
    <div class="slots" id="playerSlots"></div>
  </div>
  <div class="zone">
    <b>AI Board</b>
    <div class="slots" id="aiSlots"></div>
  </div>

  <!-- Log -->
  <div class="zone">
    <b>Log</b>
    <div class="log" id="log"></div>
  </div>
</div>

<!-- Hand (fixed) -->
<div class="handContainer">
  <div class="hand" id="hand"></div>
</div>

<script>
// DOM references
const hp          = document.getElementById('hp');
const aiHp        = document.getElementById('aiHp');
const ae          = document.getElementById('ae');
const deckCount   = document.getElementById('deckCount');
const discardCount= document.getElementById('discardCount');
const glyphCount  = document.getElementById('glyphCount');
const swSelect    = document.getElementById('swSelect');
const swDesc      = document.getElementById('swDesc');
const tranceNote  = document.getElementById('tranceNote');
const drawBtn     = document.getElementById('drawBtn');
const endBtn      = document.getElementById('endBtn');
const resetBtn    = document.getElementById('resetBtn');
const chronoBtn   = document.getElementById('chronoBtn');
const trickBtn    = document.getElementById('trickBtn');
const flowCosts   = document.getElementById('flowCosts');
const flowRow     = document.getElementById('flowRow');
const playerSlots = document.getElementById('playerSlots');
const aiSlots     = document.getElementById('aiSlots');
const handEl      = document.getElementById('hand');
const logEl       = document.getElementById('log');

function log(msg){ 
  const time = new Date().toLocaleTimeString();
  logEl.innerHTML += `<div><span class="muted">${time}</span> — ${msg}</div>`;
  logEl.scrollTop = logEl.scrollHeight;
}

function uid(){ return Math.random().toString(36).slice(2,9); }
function shuf(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function makeDeck(){ return shuf(BASE.map(x=>Object.assign({id:uid()},x))); }
function makeFlow(){ return shuf(FLOW.map(x=>Object.assign({id:uid()},x))); }

// Game state
let S = {};
function initGame(sw){
  S = {
    sw: sw || Object.keys(SPELLWEAVERS)[0],
    hp: 5,
    ae: 0,
    deck: makeDeck(),
    hand: [],
    disc: [],
    slots: [null,null,null],
    glyphs: [],
    ai: {
      hp: 5,
      ae: 0,
      deck: makeDeck(),
      hand: [],
      disc: [],
      slots: [null,null,null],
      glyphs: []
    },
    flowDeck: makeFlow(),
    flowRow: [null,null,null,null,null],
    flags: { preventOnce:false, preventAvailable:false, glyphAether:false, hasChrono:false, copyInst:false, leftDiscount:false, freeChannelOnBuy:false, trickOnce:false, trickUsed:false },
    lastInstant: null,
    turn: 1,
    tranceHit: {},
    taxes: 0,
    blockedSlots: []
  };
  for(let i=0;i<5;i++){ drawCard(); aiDraw(); }
  slideFlow(true);
  render();
}

// Render update
function render(){
  hp.textContent = S.hp;
  aiHp.textContent = S.ai.hp;
  ae.textContent = S.ae;
  deckCount.textContent = S.deck.length;
  discardCount.textContent = S.disc.length;
  glyphCount.textContent = S.glyphs.length;
  document.getElementById('turnTag').textContent = `Turn ${S.turn}`;
  swDesc.textContent = SPELLWEAVERS[S.sw].desc;
  tranceNote.textContent = "Trance at " + SPELLWEAVERS[S.sw].trance.map(t=>t.hp+"♥").join(" & ");
  // Build spellweaver select options once
  if(!swSelect.dataset.ready){
    swSelect.innerHTML = "";
    for(const k of Object.keys(SPELLWEAVERS)){
      const opt = document.createElement('option');
      opt.value = k; opt.textContent = k;
      swSelect.appendChild(opt);
    }
    swSelect.dataset.ready = "1";
  }
  swSelect.value = S.sw;

  // Flow costs & row
  flowCosts.innerHTML = "";
  for(const cost of [4,3,2,2,2]){
    const cDiv = document.createElement('div');
    cDiv.textContent = cost;
    flowCosts.appendChild(cDiv);
  }
  flowRow.innerHTML = "";
  S.flowRow.forEach((c, idx) => {
    const cardDiv = document.createElement('div');
    if(c === null){
      cardDiv.className = "card";
      cardDiv.innerHTML = `<h4 style="opacity:.5">— empty —</h4>`;
      flowRow.appendChild(cardDiv);
      return;
    }
    const fo = c.rar ? "foil" : "";
    cardDiv.className = `card ${c.c} ${fo}`;
    let rarTag = c.rar ? `<span class="rarity">${c.rar}</span>` : "";
    cardDiv.innerHTML = `
      ${rarTag}
      <h4>${c.n}</h4>
      <p>${c.txt}</p>
      <div class="actions">
        <button>Buy (${[4,3,2,2,2][idx]}⚡)</button>
      </div>
    `;
    cardDiv.querySelector('button').onclick = () => buyFlowCard(idx);
    flowRow.appendChild(cardDiv);
  });

  // Boards
  playerSlots.innerHTML = "";
  S.slots.forEach((s, i) => {
    const div = document.createElement('div');
    div.className = "slot";
    div.innerHTML = `<h5>Slot ${i+1}${S.blockedSlots.includes(i)?' — <b>Blocked</b>':''}</h5>`;
    if(s){
      const fo = s.c.rar ? "foil" : "";
      div.innerHTML += `
        <div class="card ${s.c.c} ${fo}" style="min-width:auto;max-width:none;padding:8px;margin-bottom:6px">
          <h4>${s.c.n}</h4>
          <p>Phase ${s.ph}/${s.c.p}</p>
        </div>
        <button ${s.advUsed?'disabled':''}>Advance (${1+S.taxes}⚡)</button>
      `;
      if(!s.advUsed){
        div.querySelector('button').onclick = () => {
          if(S.taxes>0) S.taxes=0;
          advance(i);
        };
      }
    }
    playerSlots.appendChild(div);
  });
  aiSlots.innerHTML = "";
  S.ai.slots.forEach((s, i) => {
    const div = document.createElement('div');
    div.className = "slot";
    div.innerHTML = `<h5>AI Slot ${i+1}</h5>`;
    if(s){
      const fo = s.c.rar ? "foil" : "";
      div.innerHTML += `
        <div class="card ${s.c.c} ${fo}" style="min-width:auto;max-width:none;padding:8px">
          <h4>${s.c.n}</h4>
          <p>Phase ${s.ph}/${s.c.p}</p>
        </div>
      `;
    }
    aiSlots.appendChild(div);
  });

  // Hand
  handEl.innerHTML = "";
  S.hand.forEach((c, idx) => {
    const holder = document.createElement('div');
    holder.className = "handCard";
    const fo = c.rar ? "foil" : "";
    holder.innerHTML = `
      <div class="card ${c.c} ${fo}">
        <h4>${c.n}</h4>
        <p>${c.txt}</p>
        <div class="actions">
          <button>${c.t==="Spell"?"Play":"Set/Play"}</button>
          <button>Channel</button>
        </div>
      </div>
    `;
    // Simplify: tapping 'Play' will automatically use the first available slot
    const [playBtn, chanBtn] = holder.querySelectorAll('button');
    playBtn.onclick = () => {
      if(c.t === "Spell"){
        const slot = S.slots.findIndex((x, i)=>!x && !S.blockedSlots.includes(i));
        if(slot<0){ log("No empty slot."); return; }
        if(triggerAmbush(S.ai)){ log("AI’s Ambush cancels your spell and deals 1."); damageYou(1); S.disc.push(c); S.hand.splice(idx,1); render(); return; }
        S.slots[slot] = {c,ph:1,advUsed:false};
        S.hand.splice(idx,1);
        log(`You play ${c.n} to Slot ${slot+1}.`);
      } else if(c.t === "Glyph"){
        S.glyphs.push(c);
        S.hand.splice(idx,1);
        log("You set a Glyph face-down.");
      } else {
        runInstant("you", c);
        S.disc.push(c);
        if(S.flags.copyInst) runInstant("you", c);
        S.hand.splice(idx,1);
        S.lastInstant = c;
      }
      render();
    };
    chanBtn.onclick = () => {
      if(c.eff==="chan_self"){ S.ae+=1; log(`Channel Spark (+1⚡)`); }
      else { S.ae += (c.v||0); log(`Channel ${c.n} (+${c.v||0}⚡)`); }
      S.disc.push(c);
      S.hand.splice(idx,1);
      render();
    };
    holder.onclick = ()=>{}; // avoid nested events
    handEl.appendChild(holder);
  });

  // Buttons
  chronoBtn.disabled = !S.flags.hasChrono;
  trickBtn.disabled  = !S.flags.trickOnce || S.flags.trickUsed;
}

function drawCard(){
  if(S.deck.length===0){ if(S.disc.length===0){ log("No cards to draw."); return; } S.deck = shuf(S.disc); S.disc = []; log("You reshuffle."); }
  S.hand.push(S.deck.pop());
}

function aiDraw(){ if(S.ai.deck.length===0){ if(S.ai.disc.length>0){ S.ai.deck = shuf(S.ai.disc); S.ai.disc=[]; log("AI reshuffles."); } else return; } S.ai.hand.push(S.ai.deck.pop()); }

function advance(slotIdx){
  const s = S.slots[slotIdx]; if(!s) return;
  const cost = 1 + S.taxes;
  if(S.ae < cost){ log(`Need ${cost}⚡ to advance.`); return; }
  S.ae -= cost; s.ph += 1; s.advUsed = true;
  if(s.ph >= s.c.p){ resolvePlayer(slotIdx); }
  render();
}

function resolvePlayer(idx){ const s=S.slots[idx]; if(!s) return; if(aiTryCounter()){ log("AI counters your spell."); S.disc.push(s.c); S.slots[idx]=null; render(); return; } runResolve("you", s.c); S.disc.push(s.c); S.slots[idx]=null; render(); }

function runResolve(who,c){
  switch(c.eff){
    case "hex_plus": if(who==="you"){ if(consumeBarrier(S.ai)){ break; } log("Hex+: AI discards 1 and loses 1⚡ (sim)."); S.ai.ae=Math.max(0,S.ai.ae-1); } else { if(consumeBarrier(S)){ break; } log("AI Hex+: you discard 1 and lose 1⚡."); S.ae=Math.max(0,S.ae-1); } break;
    case "ember": (who==="you"?damageAI(2):damageYou(2)); break;
    case "swap": log(who==="you"?"Phase Swap (no‑op)":"AI swaps (no‑op)"); break;
    case "loop": if(who==="you"){ if(S.lastInstant){ runInstant("you", S.lastInstant); } else { drawCard(); log("Loop draws 1 (no instant)"); } } break;
    case "tax": if(who==="you"){ S.ai.taxes += 1; log("Stonewall: AI’s next Advance +1⚡."); } else { S.taxes += 1; log("AI Stonewall: your next Advance +1⚡."); } break;
    case "bargain": if(who==="you"){ damageAI(3); S.hp=Math.max(0,S.hp-2); log("Recoil: you lose 2♥."); } else { damageYou(3); S.ai.hp=Math.max(0,S.ai.hp-2); log("AI recoil: loses 2♥."); } break;
  }
}

function consumeBarrier(target){ const i=target.glyphs.findIndex(g=>g.eff==="g_barrier"); if(i>-1){ target.glyphs.splice(i,1); log((target===S?"Your":"AI's")+" Barrier negates it."); return true; } return false; }

function damageYou(n){ const m=S.glyphs.findIndex(g=>g.eff==="g_mirror"); if(m>-1&&n>0){ S.glyphs.splice(m,1); log("Your Mirror Ward reflects!"); if(S.flags.glyphAether){ S.ae+=1; log("+1⚡ (glyph flip)."); } damageAI(n); return; } if(consumeBarrier(S)){ if(S.flags.glyphAether){ S.ae+=1; log("+1⚡ (glyph flip)."); } return; } let dmg=n; if(S.flags.preventAvailable){ dmg=Math.max(0,dmg-1); S.flags.preventAvailable=false; log("Ward prevents 1."); } if(dmg>0){ S.hp=Math.max(0,S.hp-dmg); log("You take "+dmg+" damage."); applyTrance(); } }
function damageAI(n){ const m=S.ai.glyphs.findIndex(g=>g.eff==="g_mirror"); if(m>-1&&n>0){ S.ai.glyphs.splice(m,1); log("AI Mirror reflects!"); damageYou(n); return; } if(consumeBarrier(S.ai)){ return; } S.ai.hp=Math.max(0,S.ai.hp-n); log("AI takes "+n+" damage."); }
function applyTrance(){ const spec=SPELLWEAVERS[S.sw]; spec.trance.forEach(step => { if(S.hp<=step.hp && !S.tranceHit[step.hp]){ step.apply(S); S.tranceHit[step.hp]=true; log("Trance triggered: "+step.label); } }); if(S.flags.preventOnce) S.flags.preventAvailable=true; render(); }

function buyFlowCard(idx){ const c=S.flowRow[idx]; if(!c){ log("Empty slot."); return; } const cost=[4,3,2,2,2][idx]- (idx===0&&S.flags.leftDiscount?1:0); if(S.ae < cost){ log("Not enough ⚡."); return; } S.ae-=cost; if(c.t==="Glyph"){ S.glyphs.push(c); log("You set "+c.n); } else { S.disc.push(c); log("You learn "+c.n); } S.flowRow[idx]=null; if(S.flags.freeChannelOnBuy && S.hand.length>0){ const d=S.hand.shift(); S.ae += d.v||0; S.disc.push(d); log("Free channel on buy: "+d.n); } render(); }

function slideFlow(initial){ if(!initial){ S.flowRow.pop(); } S.flowRow.unshift(S.flowDeck.pop()||null); render(); }

function drawCards(n=1){ for(let i=0;i<n;i++) drawCard(); }

function aiDraw(){ if(S.ai.deck.length===0){ if(S.ai.disc.length>0){ S.ai.deck=shuf(S.ai.disc); S.ai.disc=[]; log("AI reshuffles."); } else return; } S.ai.hand.push(S.ai.deck.pop()); }

function endTurn(){
  // Reset adv flags
  S.slots.forEach(s=>{ if(s) s.advUsed=false; });
  if(S.flags.preventOnce) S.flags.preventAvailable=true;
  slideFlow(); S.turn++; render(); log("Turn ends."); aiTurn();
}

function aiTurn(){
  log("— AI Turn —");
  aiDraw();
  // AI plays: simplified: play first spell if possible
  const hand= S.ai.hand; const idx=hand.findIndex(x=>x.t==="Spell");
  if(idx>-1){ const c=hand.splice(idx,1)[0]; const slot = S.ai.slots.findIndex(x=>!x); if(slot>-1){ S.ai.slots[slot]={c,ph:1,advUsed:false}; log("AI plays "+c.n); } }
  // AI channel others
  if(hand.length>0){ const r=hand.shift(); S.ai.ae += (r.v||0); S.ai.disc.push(r); log("AI channels "+r.n); }
  // AI advances one spell if possible
  const sIdx=S.ai.slots.findIndex(s=>s&&!s.advUsed); if(sIdx>-1 && S.ai.ae>0){ S.ai.ae--; S.ai.slots[sIdx].ph++; S.ai.slots[sIdx].advUsed=true; log("AI advances."); if(S.ai.slots[sIdx].ph>=S.ai.slots[sIdx].c.p){ runResolve("ai", S.ai.slots[sIdx].c); S.ai.disc.push(S.ai.slots[sIdx].c); S.ai.slots[sIdx]=null; } }
  // AI buys cheap
  for(let i=4;i>=0;i--){ const c=S.flowRow[i]; if(c && ([4,3,2,2,2][i] <= S.ai.ae)){ S.ai.ae-=[4,3,2,2,2][i]; S.ai.disc.push(c); S.flowRow[i]=null; log("AI learns "+c.n); break;} }
  // AI resets blocked slots
  S.blockedSlots=[];
  render(); log("AI ends turn.");
}

function triggerAmbush(target){ const i=target.glyphs.findIndex(g=>g.eff==="g_ambush"); if(i>-1){ target.glyphs.splice(i,1); return true; } return false; }
function aiTryCounter(){ const i=S.ai.hand.findIndex(g=>g.eff==="counter"); if(i>-1){ S.ai.hand.splice(i,1); log("AI counters."); return true; } return false; }

// Spellweaver selection
swSelect.onchange = () => {
  S.sw = swSelect.value;
  S.flags = { preventOnce:false, preventAvailable:false, glyphAether:false, hasChrono:false, copyInst:false, leftDiscount:false, freeChannelOnBuy:false, trickOnce:false, trickUsed:false };
  S.tranceHit = {};
  log("You switch Spellweaver to "+S.sw);
  render();
};

// Button handlers
drawBtn.onclick = () => { drawCard(); render(); };
endBtn.onclick  = () => endTurn();
resetBtn.onclick= () => initGame(swSelect.value);
chronoBtn.onclick = () => {
  if(S.flags.hasChrono){ const i=S.slots.findIndex(s=>s&&!s.advUsed); if(i>=0){ S.slots[i].ph++; S.slots[i].advUsed=true; log("Chrono Step used."); if(S.slots[i].ph>=S.slots[i].c.p){ resolvePlayer(i); } render(); } }
};
trickBtn.onclick = () => {
  if(S.flags.trickOnce&&!S.flags.trickUsed && S.hand.length){ const k=Math.floor(Math.random()*S.hand.length); S.disc.push(S.hand.splice(k,1)[0]); drawCard(); S.flags.trickUsed=true; log("Gamble: random discard → draw"); render(); }
};

// Initialize game
initGame();
</script>
</body>
</html>
