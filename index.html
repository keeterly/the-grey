<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>The Grey — Spellweavers</title>
<meta name="theme-color" content="#0b0d10">
<style>
:root{
  --bg:#0b0d10;--panel:#0e1218;--ink:#efece7;--muted:#b9b4ac;
  --line:#1e2631;--accent:#d7b77a;--chip:#121721;--chip-line:#223043;--slot:#0c1118;
  --card:#111621;--card-line:#23344a;--good:#78e08f;--bad:#ff7a7a;
  --whiteA:#a9d0ff;--whiteB:#6fa4ff;--grayA:#a3a7b3;--grayB:#6b7280;--blackA:#e9a8a8;--blackB:#b56565;
}
*{box-sizing:border-box;margin:0;padding:0}
body{background:var(--bg);color:var(--ink);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;min-height:100vh}
.wrap{padding:12px;max-width:1100px;margin:auto;overflow-x:hidden}
.banner{height:96px;border-radius:14px;margin-bottom:12px;position:relative;overflow:hidden;border:1px solid #202a38;background:linear-gradient(180deg,#151b26,#0e121a);box-shadow:0 8px 26px rgba(0,0,0,.35) inset,0 10px 30px rgba(0,0,0,.25)}
.banner .title{position:absolute;left:14px;top:10px;font-weight:900;letter-spacing:.14em;color:var(--accent)}
.banner .subtitle{position:absolute;left:14px;top:36px;font-size:12px;color:#9db3cc}
.banner .crest{position:absolute;right:10px;top:10px;opacity:.8;font-size:40px}
.zone{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:10px;margin-bottom:10px;box-shadow:0 6px 18px rgba(0,0,0,.25) inset}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:var(--chip);border:1px solid var(--chip-line);font-size:12px;margin-right:4px}
.badge{border:1px solid #2b3a51;background:#0b111a;color:#a9d0ff;padding:2px 6px;border-radius:6px;font-size:11px;margin-left:4px}
button,select{background:linear-gradient(180deg,#151c27,#0e141d);color:var(--ink);border:1px solid var(--line);border-radius:12px;padding:8px 10px;font-size:14px;cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}
.small{font-size:12px;color:#b9c4d2}
.hint{font-size:11px;color:#9ab;margin-top:6px}
.costRow{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:6px}
.costRow div{flex:1 0 60px;text-align:center;font-weight:700;padding:4px;border:1px solid #213145;border-radius:8px;background:#0b111a;color:var(--accent)}
.market{display:flex;flex-wrap:wrap;gap:8px;overflow-x:hidden}
.card{background:var(--card);border:1px solid var(--card-line);border-radius:14px;padding:10px;min-width:180px;flex:1 0 180px;position:relative;box-shadow:0 6px 16px rgba(0,0,0,.28);margin-bottom:8px}
.card h4{font-size:14px;color:var(--accent);margin-bottom:4px}
.card p{font-size:12px;color:var(--muted);margin-bottom:4px}
.card .actions{display:flex;gap:6px;margin-top:6px}
.card .rarity{position:absolute;top:6px;right:8px;font-size:9px;padding:2px 4px;background:#0c0c0e;border:1px solid #3c3c3c;border-radius:6px;color:#d9d3c7}
.card.white{border-image:linear-gradient(180deg,var(--whiteA),var(--whiteB)) 1;box-shadow:0 4px 12px rgba(79,153,255,.15)}
.card.gray{border-image:linear-gradient(180deg,var(--grayA),var(--grayB)) 1;box-shadow:0 4px 12px rgba(160,160,170,.14)}
.card.black{border-image:linear-gradient(180deg,var(--blackA),var(--blackB)) 1;box-shadow:0 4px 12px rgba(214,104,104,.15)}
.slots{display:flex;gap:8px;flex-wrap:wrap}
.slot{flex:1 0 30%;min-width:260px;background:var(--slot);border:2px dashed #33465d;border-radius:12px;padding:8px;min-height:140px;position:relative}
.slot h5{font-size:12px;color:var(--muted);margin-bottom:6px}
.handContainer{position:fixed;bottom:0;left:0;width:100%;background:linear-gradient(0deg,#0e1218,#151b26);padding:10px 0;box-shadow:0 -2px 10px rgba(0,0,0,.4)}
.hand{display:flex;justify-content:center;position:relative;gap:0;flex-wrap:nowrap}
.handCard{position:relative;transition:transform .2s,box-shadow .2s;cursor:pointer;margin:0 -50px;width:220px;max-width:220px}
.handCard:hover{transform:translateY(-10px) scale(1.05);box-shadow:0 8px 16px rgba(0,0,0,.5);z-index:5}
.log{max-height:200px;overflow:auto;font-size:12px}
#pendingBar{position:sticky;top:6px;z-index:9;margin:8px 0;padding:8px;border:1px solid var(--line);border-radius:10px;background:#0b111a}
</style>
</head>
<body>
<div class="wrap">
  <div class="banner">
    <div class="title">THE GREY</div>
    <div class="subtitle">Spellweavers of Venia — Aether & Omen</div>
    <div class="crest">✦</div>
  </div>

  <!-- HUD -->
  <div class="zone">
    <div class="row">
      <span class="pill">You ♥ <b id="hp">5</b></span>
      <span class="pill">AI ♥ <b id="aiHp">5</b></span>
      <span class="pill">⚡ <b id="ae">0</b></span>
      <span class="pill">Deck <b id="deckCount">0</b></span>
      <span class="pill">Discard <b id="discardCount">0</b></span>
      <span class="pill">Glyphs <b id="glyphCount">0</b></span>
      <span class="badge" id="turnTag">Turn 1</span>
    </div>
    <div class="row" style="margin-top:6px;">
      <label class="small">Spellweaver:</label>
      <select id="swSelect"></select>
      <span id="swDesc" class="small"></span>
      <span id="tranceNote" class="small"></span>
    </div>
    <div class="row" style="margin-top:8px;">
      <button id="drawBtn">Draw</button>
      <button id="endBtn">End Turn</button>
      <button id="resetBtn">Reset</button>
      <button id="chronoBtn" disabled>Chrono</button>
      <button id="trickBtn" disabled>Gamble</button>
    </div>
    <div class="hint">Spells advance only when you press Advance (max once/turn per spell). Aetherflow purchases go into your discard.</div>
  </div>

  <!-- Aetherflow -->
  <div class="zone">
    <b>Aetherflow</b>
    <div class="costRow" id="flowCosts"></div>
    <div class="market" id="flowRow"></div>
  </div>

  <!-- Boards -->
  <div class="zone">
    <b>Your Board</b>
    <div class="slots" id="playerSlots"></div>
  </div>
  <div class="zone">
    <b>AI Board</b>
    <div class="slots" id="aiSlots"></div>
  </div>

  <!-- Log -->
  <div class="zone">
    <b>Log</b>
    <div class="log" id="log"></div>
  </div>
</div>

<!-- Hand (fixed) -->
<div class="handContainer">
  <div class="hand" id="hand"></div>
</div>

<script>
// --- DOM refs ---
const hp=document.getElementById('hp'), aiHp=document.getElementById('aiHp'), ae=document.getElementById('ae');
const deckCount=document.getElementById('deckCount'), discardCount=document.getElementById('discardCount'), glyphCount=document.getElementById('glyphCount');
const swSelect=document.getElementById('swSelect'), swDesc=document.getElementById('swDesc'), tranceNote=document.getElementById('tranceNote');
const drawBtn=document.getElementById('drawBtn'), endBtn=document.getElementById('endBtn'), resetBtn=document.getElementById('resetBtn'), chronoBtn=document.getElementById('chronoBtn'), trickBtn=document.getElementById('trickBtn');
const flowCosts=document.getElementById('flowCosts'), flowRow=document.getElementById('flowRow'), playerSlots=document.getElementById('playerSlots'), aiSlots=document.getElementById('aiSlots'), handEl=document.getElementById('hand'), logEl=document.getElementById('log');

function log(m){ const t=new Date().toLocaleTimeString(); logEl.innerHTML+='<div><span style="color:#8aa">['+t+']</span> '+m+'</div>'; logEl.scrollTop=logEl.scrollHeight; }

// --- Card pools (lean for MVP) ---
const BASE=[
  {t:'Spell',c:'black',n:'Ember Lance',p:2,txt:'Deal 2.',eff:'ember'},
  {t:'Spell',c:'gray', n:'Minor Hex+',p:2,txt:'Enemy discards 1 and loses 1⚡.',eff:'hex_plus'},
  {t:'Instant',c:'white',n:'Channel Spark',txt:'+1⚡ then discard.',eff:'chan_self',v:1},
  {t:'Instant',c:'white',n:'Meditate',txt:'Draw 1.',eff:'draw1'},
  {t:'Glyph',c:'gray', n:'Barrier Ward',txt:'Prevent next damage to you.',eff:'g_barrier'}
];
const FLOW=[
  {t:'Spell',c:'white',n:'Phase Swap',p:2,txt:'Swap phases (demo).',eff:'swap'},
  {t:'Spell',c:'black',n:'Dark Bargain',p:2,txt:'Deal 3; you lose 2♥.',eff:'bargain'},
  {t:'Spell',c:'gray', n:'Stonewall',p:2,txt:'Opp. next Advance +1⚡.',eff:'tax'},
  {t:'Instant',c:'white',n:'Loop Sigil',txt:'Repeat your last Instant (or draw).',eff:'loop'},
  {t:'Glyph',c:'gray', n:'Mirror Ward',txt:'Reflect next damage to sender.',eff:'g_mirror'},
  {t:'Glyph',c:'black',n:'Ambush Rune',txt:'Cancel next enemy play; they take 1.',eff:'g_ambush'}
];
// --- Spellweavers & Trance thresholds ---
const SPELLWEAVERS={
  Aurora:{desc:'White tempo. Gains +1⚡ on first glyph flip each turn.', trance:[
    {hp:3,label:'+1♥ guard (once/turn)',apply:(S)=>{S.flags.preventOnce=true;}}
  ]},
  Rook:{desc:'Gray bulwark. First Advance each turn -1⚡ (once).', trance:[
    {hp:2,label:'Leftmost Flow -1⚡',apply:(S)=>{S.flags.leftDiscount=true;}}
  ]},
  Nox:{desc:'Black aggression. One-time instant copy.', trance:[
    {hp:1,label:'Copy next Instant played this turn',apply:(S)=>{S.flags.copyInst=true;}}
  ]}
};

// --- Utilities ---
function uid(){return Math.random().toString(36).slice(2,9)}
function shuf(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]} return a}
function makeDeck(){return shuf(BASE.map(x=>Object.assign({id:uid()},x)))}
function makeFlow(){return shuf(FLOW.map(x=>Object.assign({id:uid()},x)))}

// --- State ---
let S={};

function initGame(sw){
  S={
    sw: sw || Object.keys(SPELLWEAVERS)[0],
    hp:5, ae:0, deck:makeDeck(), hand:[], disc:[], glyphs:[], slots:[null,null,null],
    ai:{hp:5, ae:0, deck:makeDeck(), hand:[], disc:[], glyphs:[], slots:[null,null,null]},
    flowDeck:makeFlow(), flowRow:[null,null,null,null,null],
    flags:{preventOnce:false,preventAvailable:false,glyphAether:false,hasChrono:false,copyInst:false,leftDiscount:false,freeChannelOnBuy:false,trickOnce:false,trickUsed:false},
    lastInstant:null, turn:1, tranceHit:{}, taxes:0, blockedSlots:[], pending:null
  };
  for(let i=0;i<5;i++){ drawCard(); aiDraw(); }
  slideFlow(true);
  render();
}

// --- Spellweaver selection ---
function setSpellweaver(name){
  S.sw=name;
  S.flags.preventOnce=false; S.flags.preventAvailable=false; S.tranceHit={};
  log('You switch Spellweaver to '+name);
  render();
}

// --- Rendering ---
function render(){
  // HUD
  hp.textContent=S.hp; aiHp.textContent=S.ai.hp; ae.textContent=S.ae;
  deckCount.textContent=S.deck.length; discardCount.textContent=S.disc.length; glyphCount.textContent=S.glyphs.length;
  document.getElementById('turnTag').textContent='Turn '+S.turn;
  swDesc.textContent=SPELLWEAVERS[S.sw].desc;
  tranceNote.textContent='Trance at '+SPELLWEAVERS[S.sw].trance.map(t=>t.hp+'♥').join(' & ');

  // SW dropdown once
  if(!swSelect.dataset.ready){
    Object.keys(SPELLWEAVERS).forEach(k=>{const o=document.createElement('option');o.value=k;o.textContent=k;swSelect.appendChild(o)});
    swSelect.dataset.ready='1';
  }
  swSelect.value=S.sw;

  // Flow costs
  flowCosts.innerHTML='';
  [4,3,2,2,2].forEach(c=>{const d=document.createElement('div');d.textContent=c;flowCosts.appendChild(d)})

  // Flow row
  flowRow.innerHTML='';
  S.flowRow.forEach((c,i)=>{
    const k=document.createElement('div');k.className='card';
    if(!c){ k.innerHTML='<h4 style="opacity:.5">— empty —</h4>'; flowRow.appendChild(k); return; }
    k.className+=' '+c.c;
    k.innerHTML='<h4>'+c.n+'</h4><p>'+c.txt+'</p><div class="actions"><button>Buy ('+[4,3,2,2,2][i]+'⚡)</button></div>';
    k.querySelector('button').onclick=()=>buyFlowCard(i);
    flowRow.appendChild(k);
  });

  // Pending bar
  const ex=document.getElementById('pendingBar'); if(ex) ex.remove();
  if(S.pending){
    const bar=document.createElement('div'); bar.id='pendingBar';
    const c=S.hand[S.pending.handIdx];
    bar.innerHTML='<b>Placing:</b> '+(c?c.n:'—')+' <button style="float:right">Cancel</button>';
    bar.querySelector('button').onclick=()=>{S.pending=null; render();};
    document.querySelector('.wrap .zone').prepend(bar);
  }

  // Player slots
  playerSlots.innerHTML='';
  S.slots.forEach((s,i)=>{
    const d=document.createElement('div'); d.className='slot';
    let title='Slot '+(i+1)+(S.blockedSlots.includes(i)?' — <b>Blocked</b>':'');
    d.innerHTML='<h5>'+title+'</h5>';
    if(s){
      d.innerHTML+='<div class="card" style="min-width:auto;max-width:none;padding:8px;margin-bottom:6px"><h4>'+s.c.n+'</h4><p>Phase '+s.ph+'/'+s.c.p+'</p></div>';
      const b=document.createElement('button'); b.textContent='Advance ('+(1+S.taxes)+'⚡)'; b.disabled=!!s.advUsed;
      if(!s.advUsed) b.onclick=()=>{ advance(i); };
      d.appendChild(b);
    }
    // Play Here prompts
    if(S.pending && !S.slots[i] && !S.blockedSlots.includes(i)){
      const ph=document.createElement('button'); ph.textContent='Play Here'; ph.style.marginTop='6px'; ph.style.width='100%';
      ph.onclick=()=>playInto(i); d.appendChild(ph);
    }
    playerSlots.appendChild(d);
  });

  // AI slots
  aiSlots.innerHTML='';
  S.ai.slots.forEach((s,i)=>{
    const d=document.createElement('div'); d.className='slot';
    d.innerHTML='<h5>AI Slot '+(i+1)+'</h5>';
    if(s){ d.innerHTML+='<div class="card" style="min-width:auto;max-width:none;padding:8px"><h4>'+s.c.n+'</h4><p>Phase '+s.ph+'/'+s.c.p+'</p></div>'; }
    aiSlots.appendChild(d);
  });

  // Hand
  handEl.innerHTML='';
  S.hand.forEach((c,idx)=>{
    const h=document.createElement('div'); h.className='handCard';
    h.innerHTML='<div class="card"><h4>'+c.n+'</h4><p>'+c.txt+'</p><div class="actions"><button>'+(c.t==='Spell'?'Play':'Set/Play')+'</button><button>Channel</button></div></div>';
    const [playBtn,chanBtn]=h.querySelectorAll('button');
    playBtn.onclick=()=>{
      if(c.t==='Spell'){ startPlay(idx); }
      else if(c.t==='Glyph'){ S.glyphs.push(c); S.hand.splice(idx,1); log('You set a Glyph.'); render(); }
      else { runInstant('you',c); S.disc.push(c); if(S.flags.copyInst) runInstant('you',c); S.hand.splice(idx,1); S.lastInstant=c; render(); }
    };
    chanBtn.onclick=()=>{ const val=c.v||0; S.ae+=val; S.disc.push(c); S.hand.splice(idx,1); log('Channel '+c.n+' (+'+val+'⚡)'); render(); };
    handEl.appendChild(h);
  });

  chronoBtn.disabled=!S.flags.hasChrono;
  trickBtn.disabled=!S.flags.trickOnce || S.flags.trickUsed;
}

// --- Placement helpers (no drag) ---
function startPlay(handIdx){ const c=S.hand[handIdx]; if(!c||c.t!=='Spell') return; S.pending={handIdx}; log('Choose a slot for '+c.n+'.'); render(); }
function playInto(slotIdx){
  if(!S.pending) return;
  const h=S.pending.handIdx; const c=S.hand[h]; if(!c||c.t!=='Spell'){S.pending=null; render(); return;}
  if(S.slots[slotIdx] || S.blockedSlots.includes(slotIdx)){ log('That slot is not available.'); return; }
  if(triggerAmbush(S.ai)){ log('AI’s Ambush cancels your spell and deals 1.'); damageYou(1); S.disc.push(c); S.hand.splice(h,1); S.pending=null; render(); return; }
  S.slots[slotIdx]={c,ph:1,advUsed:false}; S.hand.splice(h,1); log('You play '+c.n+' to Slot '+(slotIdx+1)+'.'); S.pending=null; render();
}

// --- Core actions ---
function drawCard(){
  if(S.deck.length===0){ if(S.disc.length===0){ log('No cards to draw.'); return; } S.deck=shuf(S.disc); S.disc=[]; log('You reshuffle.'); }
  S.hand.push(S.deck.pop());
}
function aiDraw(){ if(S.ai.deck.length===0){ if(S.ai.disc.length>0){ S.ai.deck=shuf(S.ai.disc); S.ai.disc=[]; log('AI reshuffles.'); } else return; } S.ai.hand.push(S.ai.deck.pop()); }

function advance(i){
  const s=S.slots[i]; if(!s) return;
  const cost=1+S.taxes; if(S.ae<cost){ log('Need '+cost+'⚡ to advance.'); return; }
  S.ae-=cost; s.ph++; s.advUsed=true; if(s.ph>=s.c.p){ resolvePlayer(i); } render();
}

function resolvePlayer(i){
  const s=S.slots[i]; if(!s) return;
  if(aiTryCounter()){ log('AI counters your spell.'); S.disc.push(s.c); S.slots[i]=null; render(); return; }
  runResolve('you', s.c); S.disc.push(s.c); S.slots[i]=null; render();
}

function runResolve(who,c){
  switch(c.eff){
    case 'ember': (who==='you'?damageAI(2):damageYou(2)); break;
    case 'hex_plus':
      if(who==='you'){ if(consumeBarrier(S.ai)) break; log('Hex+: AI discards 1 and loses 1⚡ (sim).'); S.ai.ae=Math.max(0,S.ai.ae-1); if(S.ai.hand.length) S.ai.disc.push(S.ai.hand.pop()); }
      else { if(consumeBarrier(S)) break; log('AI Hex+: you discard 1 and lose 1⚡.'); S.ae=Math.max(0,S.ae-1); if(S.hand.length) S.disc.push(S.hand.pop()); }
      break;
    case 'swap': log((who==='you'?'Phase Swap (demo)':'AI swaps (demo)')); break;
    case 'loop':
      if(who==='you'){ if(S.lastInstant){ runInstant('you',S.lastInstant); } else { drawCard(); log('Loop: draw 1'); } }
      break;
    case 'tax':
      if(who==='you'){ S.ai.taxes=(S.ai.taxes||0)+1; log('Stonewall: AI next Advance +1⚡.'); }
      else { S.taxes+=1; log('AI Stonewall: your next Advance +1⚡.'); }
      break;
    case 'bargain':
      if(who==='you'){ damageAI(3); S.hp=Math.max(0,S.hp-2); log('Recoil: you lose 2♥.'); applyTrance(); }
      else { damageYou(3); S.ai.hp=Math.max(0,S.ai.hp-2); log('AI recoil: loses 2♥.'); }
      break;
  }
}

function runInstant(who,c){
  switch(c.eff){
    case 'chan_self': if(who==='you'){ S.ae+=1; log('+1⚡'); } else { S.ai.ae+=1; } break;
    case 'draw1': if(who==='you') { drawCard(); log('Draw 1'); } else { aiDraw(); } break;
  }
}

function consumeBarrier(t){ const i=t.glyphs.findIndex(g=>g.eff==='g_barrier'); if(i>-1){ t.glyphs.splice(i,1); log((t===S?'Your':'AI')+' Barrier negates it.'); return true;} return false; }
function triggerAmbush(t){ const i=t.glyphs.findIndex(g=>g.eff==='g_ambush'); if(i>-1){ t.glyphs.splice(i,1); return true;} return false; }
function aiTryCounter(){ const i=S.ai.hand.findIndex(g=>g.eff==='counter'); if(i>-1){ S.ai.hand.splice(i,1); return true;} return false; }

function damageYou(n){
  const m=S.glyphs.findIndex(g=>g.eff==='g_mirror'); if(m>-1&&n>0){ S.glyphs.splice(m,1); log('Your Mirror reflects!'); damageAI(n); return; }
  if(consumeBarrier(S)) return;
  let dmg=n;
  if(S.flags.preventAvailable){ dmg=Math.max(0,dmg-1); S.flags.preventAvailable=false; log('Ward prevents 1.'); }
  if(dmg>0){ S.hp=Math.max(0,S.hp-dmg); log('You take '+dmg+' damage.'); applyTrance(); }
}
function damageAI(n){
  const m=S.ai.glyphs.findIndex(g=>g.eff==='g_mirror'); if(m>-1&&n>0){ S.ai.glyphs.splice(m,1); log('AI Mirror reflects!'); damageYou(n); return; }
  if(consumeBarrier(S.ai)) return;
  S.ai.hp=Math.max(0,S.ai.hp-n); log('AI takes '+n+' damage.');
}

function applyTrance(){
  const spec=SPELLWEAVERS[S.sw];
  spec.trance.forEach(step=>{
    if(S.hp<=step.hp && !S.tranceHit[step.hp]){
      step.apply(S); S.tranceHit[step.hp]=true; log('Trance triggered: '+step.label);
    }
  });
  if(S.flags.preventOnce) S.flags.preventAvailable=true;
}

// --- Flow / shop ---
function buyFlowCard(i){
  const c=S.flowRow[i]; if(!c){ log('Empty slot.'); return; }
  const base=[4,3,2,2,2][i]; const cost=base - ((i===0 && S.flags.leftDiscount)?1:0);
  if(S.ae<cost){ log('Not enough ⚡.'); return; }
  S.ae-=cost;
  if(c.t==='Glyph'){ S.glyphs.push(c); log('You set '+c.n); }
  else { S.disc.push(c); log('You learn '+c.n); }
  S.flowRow[i]=null;
  if(S.flags.freeChannelOnBuy && S.hand.length){ const d=S.hand.shift(); S.ae+=(d.v||0); S.disc.push(d); log('Free channel on buy: '+d.n); }
  render();
}
function slideFlow(initial){ if(!initial) S.flowRow.pop(); S.flowRow.unshift(S.flowDeck.pop()||null); render(); }

// --- Turn structure ---
function endTurn(){
  S.slots.forEach(s=>{ if(s) s.advUsed=false; });
  S.pending=null;
  slideFlow(); S.turn++; render(); log('Turn ends.'); aiTurn();
}

function aiTurn(){
  log('— AI Turn —'); aiDraw();
  const h=S.ai.hand, idx=h.findIndex(x=>x.t==='Spell');
  if(idx>-1){ const c=h.splice(idx,1)[0]; const slot=S.ai.slots.findIndex(x=>!x); if(slot>-1){ S.ai.slots[slot]={c,ph:1,advUsed:false}; log('AI plays '+c.n); } }
  // channel one
  if(S.ai.hand.length){ const r=S.ai.hand.shift(); S.ai.ae+=(r.v||0); S.ai.disc.push(r); log('AI channels '+r.n); }
  // advance once if possible
  const sIdx=S.ai.slots.findIndex(s=>s&&!s.advUsed); if(sIdx>-1 && S.ai.ae>0){ S.ai.ae--; S.ai.slots[sIdx].ph++; S.ai.slots[sIdx].advUsed=true; log('AI advances.'); if(S.ai.slots[sIdx].ph>=S.ai.slots[sIdx].c.p){ runResolve('ai',S.ai.slots[sIdx].c); S.ai.disc.push(S.ai.slots[sIdx].c); S.ai.slots[sIdx]=null; } }
  // buy cheap
  for(let i=4;i>=0;i--){ const c=S.flowRow[i]; const cost=[4,3,2,2,2][i]; if(c && cost<=S.ai.ae){ S.ai.ae-=cost; if(c.t==='Glyph') S.ai.glyphs.push(c); else S.ai.disc.push(c); S.flowRow[i]=null; log('AI learns '+c.n); break; } }
  S.blockedSlots=[]; render(); log('AI ends turn.');
}

// --- UI events ---
swSelect.onchange=()=>setSpellweaver(swSelect.value);
drawBtn.onclick=()=>{ drawCard(); render(); };
endBtn.onclick =()=> endTurn();
resetBtn.onclick=()=> initGame(swSelect.value);
chronoBtn.onclick=()=>{
  if(S.flags.hasChrono){
    const i=S.slots.findIndex(s=>s&&!s.advUsed); if(i>=0){ S.slots[i].ph++; S.slots[i].advUsed=true; log('Chrono Step used.'); if(S.slots[i].ph>=S.slots[i].c.p){ resolvePlayer(i); } render(); }
  }
};
trickBtn.onclick=()=>{
  if(S.flags.trickOnce&&!S.flags.trickUsed&&S.hand.length){ const k=Math.floor(Math.random()*S.hand.length); S.disc.push(S.hand.splice(k,1)[0]); drawCard(); S.flags.trickUsed=true; log('Gamble: random discard → draw'); render(); }
};

// --- Boot ---
function drawCard(){ if(S.deck.length===0){ if(S.disc.length===0){ log('No cards to draw.'); return;} S.deck=shuf(S.disc); S.disc=[]; log('You reshuffle.'); } S.hand.push(S.deck.pop()); }
initGame();
</script>
</body>
</html>
