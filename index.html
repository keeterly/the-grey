<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>The Grey — Spellweavers (Mobile)</title>
<meta name="theme-color" content="#0b0d10" />
<style>
:root{
  --bg:#0b0d10; --panel:#0e1218; --ink:#efece7; --muted:#b9b4ac;
  --line:#1e2631; --accent:#d7b77a; --chip:#121721; --chip-line:#223043; --slot:#0c1118;
  --card:#111621; --card-line:#23344a; --good:#78e08f; --bad:#ff7a7a;
  --whiteA:#a9d0ff; --whiteB:#6fa4ff;
  --grayA:#a3a7b3;  --grayB:#6b7280;
  --blackA:#e9a8a8; --blackB:#b56565;
}
*{box-sizing:border-box}
html,body{
  margin:0;padding:0;background:radial-gradient(1200px 600px at 20% -10%,#162030 0%,#0b0d10 55%), #0b0d10;
  color:var(--ink);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
  -webkit-tap-highlight-color:transparent; overflow-x:hidden;
}
.wrap{padding:max(env(safe-area-inset-top),12px) 12px 14px;max-width:1100px;margin:0 auto}

/* Banner + stars */
.banner{height:100px;border-radius:14px;margin:8px 0 12px;position:relative;overflow:hidden;border:1px solid #202a38;background:linear-gradient(180deg,#151b26,#0e121a);box-shadow:0 8px 26px rgba(0,0,0,.35) inset,0 10px 30px rgba(0,0,0,.25)}
.banner .title{position:absolute;left:14px;top:12px;font-weight:900;letter-spacing:.14em;color:var(--accent)}
.banner .subtitle{position:absolute;left:14px;top:40px;font-size:12px;color:#9db3cc}
.banner .crest{position:absolute;right:10px;top:10px;opacity:.85}
.banner .stars,.banner .stars2{position:absolute;inset:0;background-repeat:repeat;background-size:800px 800px;opacity:.55;pointer-events:none}
.banner .stars{background-image:
  radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.8) 50%, transparent 55%),
  radial-gradient(1.5px 1.5px at 70% 60%, rgba(255,255,255,.7) 50%, transparent 55%),
  radial-gradient(1px 1px at 40% 80%, rgba(255,255,255,.6) 50%, transparent 55%); animation:drift 38s linear infinite}
.banner .stars2{background-image:
  radial-gradient(1.5px 1.5px at 10% 20%, rgba(255,255,255,.7) 50%, transparent 55%),
  radial-gradient(1px 1px at 65% 35%, rgba(255,255,255,.5) 50%, transparent 55%),
  radial-gradient(2px 2px at 85% 75%, rgba(255,255,255,.8) 50%, transparent 55%); animation:drift2 65s linear infinite; opacity:.35}
@keyframes drift{to{background-position:800px 0,400px 0,1200px 0}} @keyframes drift2{to{background-position:-600px 0,-900px 0,-300px 0}}
.banner svg.bline{position:absolute;inset:0;opacity:.32;filter:drop-shadow(0 2px 10px rgba(0,0,0,.6))}

/* Blocks */
.zone{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:10px;margin:10px 0;box-shadow:0 6px 18px rgba(0,0,0,.25) inset}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.col{flex:1;min-width:280px}
.pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:var(--chip);border:1px solid var(--chip-line);font-size:12px}
.small{font-size:12px;color:var(--muted)}
.badge{display:inline-block;border:1px solid #2b3a51;background:#0b111a;color:#a9d0ff;padding:2px 6px;border-radius:6px;font-size:11px}
.hint{font-size:11px;color:#9ab}
button,select{background:linear-gradient(180deg,#151c27,#0e141d);color:var(--ink);border:1px solid var(--line);border-radius:12px;padding:10px 12px;font-size:14px;touch-action:manipulation}
button:disabled{opacity:.6}

/* Market */
.market{display:grid;grid-template-columns:repeat(5,220px);gap:8px;overflow-x:auto;-webkit-overflow-scrolling:touch}
.costs{display:grid;grid-template-columns:repeat(5,220px);gap:8px;margin-bottom:6px;overflow-x:auto}
.cost{text-align:center;font-weight:900;padding:6px 0;background:#0b111a;border:1px solid #213145;border-radius:10px;color:var(--accent)}

/* Cards */
.card{position:relative;background:#111621;border:1px solid var(--card-line);border-radius:14px;padding:10px;min-width:180px;max-width:220px;box-shadow:0 6px 16px rgba(0,0,0,.28)}
.card .name{font-weight:900;color:var(--accent);letter-spacing:.02em;margin:.25rem 0}
.tag{font-size:10px;padding:2px 6px;border-radius:6px;border:1px solid #2d3f56;background:#0b111a;margin-right:4px}
.tag.white{background:#142235} .tag.gray{background:#1b1f27} .tag.black{background:#20151a}
.smallmuted{font-size:12px;color:var(--muted)}
.card:before{content:"";position:absolute;inset:0;border-radius:12px;opacity:.1;pointer-events:none;background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="180" height="240" viewBox="0 0 180 240"><g fill="none" stroke="%23a99a7a" stroke-width="0.6" opacity="0.6"><circle cx="30" cy="40" r="14"/><path d="M12 38 L30 10 L48 38 Z"/><circle cx="140" cy="60" r="10"/><path d="M130 90 q10 -16 20 0"/></g></svg>'); background-size:180px 240px;background-repeat:no-repeat;background-position:top right}
.card.white{border-image:linear-gradient(180deg,var(--whiteA),var(--whiteB)) 1; box-shadow:0 8px 22px rgba(79,153,255,.15)}
.card.gray{ border-image:linear-gradient(180deg,var(--grayA),var(--grayB)) 1; box-shadow:0 8px 22px rgba(160,160,170,.14)}
.card.black{border-image:linear-gradient(180deg,var(--blackA),var(--blackB)) 1; box-shadow:0 8px 22px rgba(214,104,104,.15)}
.frameSvg{position:absolute;inset:6px;pointer-events:none;opacity:.65}
.art{height:92px;border-radius:10px;margin:6px 0 8px;position:relative;overflow:hidden;background:linear-gradient(180deg,#0f1520,#0a0f16);border:1px solid #223044}
.art.white{background:radial-gradient(60px 40px at 30% 20%, rgba(120,170,255,.20), transparent 60%),linear-gradient(180deg,#101827,#0b111a)}
.art.gray{ background:radial-gradient(60px 40px at 70% 30%, rgba(180,180,195,.20), transparent 60%),linear-gradient(180deg,#0f1217,#0b0f14)}
.art.black{background:radial-gradient(60px 40px at 50% 50%, rgba(210,110,110,.18), transparent 60%),linear-gradient(180deg,#171114,#0f0b0d)}
.art svg{position:absolute;inset:0;opacity:.35}
.foil{position:relative;overflow:hidden}
.foil:after{content:"";position:absolute;inset:-20%;background:
  linear-gradient(130deg, rgba(255,255,255,0) 35%, rgba(255,255,255,.25) 45%, rgba(255,255,255,0) 60%),
  repeating-linear-gradient(130deg, rgba(255,200,150,.10) 0 6px, rgba(150,200,255,.10) 6px 12px, rgba(230,180,255,.10) 12px 18px);
  filter:blur(1px);mix-blend-mode:screen;transform:translateX(-120%) rotate(6deg);animation:foilSweep 5.5s ease-in-out infinite;pointer-events:none}
@keyframes foilSweep{0%{transform:translateX(-120%) rotate(6deg);opacity:.55}45%{transform:translateX(25%) rotate(6deg);opacity:.8}100%{transform:translateX(120%) rotate(6deg);opacity:.55}}
.rarity{position:absolute;right:8px;top:8px;font-size:10px;padding:2px 6px;border-radius:6px;border:1px solid #3c3c3c;color:#d9d3c7;background:#0c0c0e;opacity:.9}

/* Fanned hand (MTGA/StS-style) */
.hand-rail{position:relative;height:260px;border-radius:16px;background:linear-gradient(180deg,#0b1114,#0a0f15);border:1px dashed #263445;padding-bottom:8px}
.hand{position:absolute;left:50%;bottom:8px;transform:translateX(-50%);height:240px;pointer-events:none}
.hand .hc{position:absolute;bottom:0;left:50%;transform-origin:50% 120%;transition:transform .12s ease, filter .12s ease;pointer-events:auto}
.hc .card{width:195px}
.hc[data-raise="1"]{transform:translate(-50%, -14px) scale(1.05);z-index:10;filter:drop-shadow(0 12px 18px rgba(0,0,0,.45))}
.hand-actions{display:none;gap:6px;flex-wrap:wrap;margin-top:6px}
.hc[data-raise="1"] .hand-actions{display:flex}
.cardActionsSpacer{height:6px}

/* Boards */
.slots{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.slot{background:var(--slot);border:2px dashed #33465d;border-radius:12px;min-height:170px;padding:8px;transition:border-color .1s ease, box-shadow .1s ease}
.slot.hot{border-color:#86b7ff;box-shadow:0 0 0 3px rgba(134,183,255,.2) inset}
.slot .p{font-size:12px;color:var(--muted);margin-bottom:6px}

/* Glyphs */
.glyphs{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
.glyphFace{height:14px;width:96px;background:linear-gradient(90deg,#0b111a,#131a27);border:1px solid #2d3f56;border-radius:8px}

/* Log */
.log{background:#0b111a;border:1px solid #1c2a3a;border-radius:10px;padding:8px;height:190px;overflow:auto;font-size:12px}
.muted{color:var(--muted)} .good{color:var(--good)} .bad{color:var(--bad)}
</style>
</head>
<body>
<div class="wrap">
  <!-- Banner -->
  <div class="banner">
    <div class="stars"></div><div class="stars2"></div>
    <svg class="bline" viewBox="0 0 1200 200" preserveAspectRatio="xMidYMid slice">
      <defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="0"><stop offset="0" stop-color="#d7b77a"/><stop offset="1" stop-color="#506b8e"/></linearGradient></defs>
      <g fill="none" stroke="url(#g)" stroke-opacity=".38">
        <path d="M0,160 Q150,40 300,160 T600,160 T900,160 T1200,160" stroke-width="2"/>
        <circle cx="220" cy="110" r="10"/><circle cx="580" cy="85" r="8"/><circle cx="940" cy="120" r="12"/>
        <path d="M460,30 l30,50 l-60,0 Z" />
      </g>
    </svg>
    <div class="title">THE GREY</div>
    <div class="subtitle">Spellweavers of Venia — Aether & Omen</div>
    <svg viewBox="0 0 90 90" class="crest" width="90" height="90"><g fill="none" stroke="#d7b77a" opacity=".85"><circle cx="45" cy="45" r="22"/><path d="M45 18 L58 40 L32 40 Z"/><circle cx="45" cy="45" r="6"/></g></svg>
  </div>

  <!-- HUD -->
  <div class="zone">
    <div class="row">
      <span class="pill">You ♥ <b id="hp">5</b></span>
      <span class="pill">AI ♥ <b id="aiHp">5</b></span>
      <span class="pill">⚡ <b id="ae">0</b></span>
      <span class="pill">Deck <b id="deck">0</b></span>
      <span class="pill">Discard <b id="disc">0</b></span>
      <span class="pill">Glyphs <b id="glyphs">0</b></span>
      <span class="badge" id="turnTag">Turn 1</span>
    </div>
    <div class="row" style="margin-top:8px;align-items:flex-start">
      <div><b>Spellweaver:</b> <select id="swSelect"></select></div>
      <div class="small" id="swDesc" style="flex:1"></div>
      <div class="small" id="tranceNote"></div>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="drawBtn">Draw</button>
      <button id="endBtn">End Turn</button>
      <button id="resetBtn">Reset</button>
      <button id="chronoBtn" disabled>Chrono Step</button>
      <button id="trickBtn" disabled>Gamble</button>
    </div>
    <div class="hint">Spells advance only when you press <i>Advance</i> (max once/turn per spell). Aetherflow purchases go to your discard.</div>
  </div>

  <!-- Aetherflow -->
  <div class="zone">
    <b>Aetherflow</b>
    <div class="costs" id="mCosts"></div>
    <div class="market" id="mRow"></div>
  </div>

  <!-- Hand -->
  <div class="zone">
    <b>Your Hand</b>
    <div class="hand-rail"><div class="hand" id="hand"></div></div>
  </div>

  <!-- Boards -->
  <div class="zone row">
    <div class="col">
      <b>Your Board</b>
      <div class="slots" id="slots"></div>
      <div class="glyphs" id="glyphView"></div>
    </div>
    <div class="col">
      <b>AI Board</b>
      <div class="slots" id="aiSlots"></div>
    </div>
  </div>

  <!-- Log -->
  <div class="zone">
    <b>Log</b>
    <div class="log" id="log"></div>
  </div>
</div>

<script>
document.addEventListener('touchstart',()=>{}, {passive:true});
function bindTap(el,fn){ el.addEventListener('click',fn); el.addEventListener('touchend',e=>{ e.preventDefault(); fn(e); }, {passive:false}); }

/* Spellweavers (unchanged from prior) */
const SPELLWEAVERS = {
  "Seraya (Wardsinger)": {
    desc: "Trance at 3♥: prevent 1 dmg each round • Trance at 1♥: +1⚡ when one of your glyphs flips",
    trance: [
      {hp:3, apply:s=>{ s.flags.preventOnce=true; s.flags.preventAvailable=true; }, label:"Ward online (prevent 1/round)."},
      {hp:1, apply:s=>{ s.flags.glyphAether=true; }, label:"+1⚡ on glyph flip."}
    ]
  },
  "Thalorin (Chronomancer)": {
    desc: "Trance at 4♥: once/turn free +1 advance • Trance at 2♥: copy your Instants",
    trance: [
      {hp:4, apply:s=>{ s.flags.hasChrono=true; s.flags.chronoUsed=false; }, label:"Chrono Step unlocked."},
      {hp:2, apply:s=>{ s.flags.copyInst=true; }, label:"Instant Echo enabled."}
    ]
  },
  "Kaelis (Aether Savant)": {
    desc: "Trance at 2♥: leftmost Aetherflow costs -1 • Trance at 1♥: free channel the top card of your hand when you buy",
    trance: [
      {hp:2, apply:s=>{ s.flags.leftDiscount=true; }, label:"Leftmost Flow -1⚡."},
      {hp:1, apply:s=>{ s.flags.freeChannelOnBuy=true; }, label:"Free channel on buy."}
    ]
  },
  "Zarik (Trickster)": {
    desc: "Trance at 3♥: once/turn Gamble (random discard → draw) • Trance at 1♥: 50% deflect (future)",
    trance: [
      {hp:3, apply:s=>{ s.flags.trickOnce=true; s.flags.trickUsed=false; }, label:"Gamble unlocked."},
      {hp:1, apply:s=>{ s.flags.trickCancel=true; }, label:"Chance to deflect (not simulated)."}
    ]
  }
};

/* Base deck (6 cards) */
const BASE = [
  {n:"Spark",t:"Instant",c:"black",v:1,txt:"Deal 1 dmg.",eff:"spark"},
  {n:"Spark",t:"Instant",c:"black",v:1,txt:"Deal 1 dmg.",eff:"spark"},
  {n:"Shield Flicker",t:"Instant",c:"white",v:1,txt:"Prevent 1 dmg this round.",eff:"shield"},
  {n:"Channel Spark",t:"Utility",c:"gray",v:0,txt:"Self-discard: +1⚡.",eff:"chan_self"},
  {n:"Minor Hex",t:"Spell",c:"gray",v:1,p:2,txt:"After 2: foe discards 1 and loses 1⚡.",eff:"hex_plus"},
  {n:"Emberbolt",t:"Spell",c:"black",v:1,p:3,txt:"After 3: deal 2 dmg.",eff:"ember"}
];

/* Aetherflow (cheaper costs; new test cards) */
const FLOW = [
  {n:"Accelerate",t:"Instant",c:"white",v:1,txt:"Advance one of your spells +1.",eff:"accel"},
  {n:"Temporal Loop",t:"Spell",c:"white",v:2,p:2,txt:"After 2: replay your last Instant (or draw).",eff:"loop",rar:"Legendary"},
  {n:"Chrono Barrier",t:"Glyph",c:"white",v:1,txt:"When targeted: negate spell/dmg.",eff:"g_barrier"},
  {n:"Meditate",t:"Instant",c:"gray",v:0,txt:"Gain 1⚡ and draw 1.",eff:"med"},
  {n:"Phase Swap",t:"Spell",c:"gray",v:1,p:2,txt:"After 2: swap two of your spells.",eff:"swap"},
  {n:"Stonewall",t:"Spell",c:"gray",v:1,p:2,txt:"After 2: opponent’s next Advance costs +1⚡.",eff:"tax"},
  {n:"Mirror Ward",t:"Glyph",c:"gray",v:1,txt:"When you’d take dmg: reflect it.",eff:"g_mirror"},
  {n:"Dark Bargain",t:"Spell",c:"black",v:2,p:3,txt:"After 3: deal 3 dmg; you lose 2♥.",eff:"bargain",rar:"Legendary"},
  {n:"Venom Dart",t:"Instant",c:"black",v:1,txt:"Deal 1 dmg & foe discards 1.",eff:"venom"},
  {n:"Seal of Binding",t:"Glyph",c:"black",v:1,txt:"On enemy spell play: cancel & block that slot until their next turn.",eff:"g_bind"},
  {n:"Null Pulse",t:"Instant",c:"white",v:1,txt:"Counter: cancel a resolving spell.",eff:"counter"}
];

/* State */
let S={};
function uid(){ return Math.random().toString(36).slice(2,9); }
function shuf(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function makeDeck(){ return shuf(BASE.map(x=>Object.assign({id:uid()},x))); }
function makeFlow(){ return shuf(FLOW.map(x=>Object.assign({id:uid()},x))); }
function log(m){ const el=document.getElementById('log'); const t=new Date().toLocaleTimeString(); el.innerHTML+=`<div><span class="muted">${t}</span> — ${m}</div>`; el.scrollTop=el.scrollHeight; }

// Cache frequently used DOM elements once after the page loads. Without these
// declarations the script will throw reference errors because variables such
// as `hp`, `aiHp`, `drawBtn`, etc. would be undefined. Defining them here
// ensures that subsequent functions can update the UI correctly.
const hp        = document.getElementById('hp');
const aiHp      = document.getElementById('aiHp');
const ae        = document.getElementById('ae');
const deck      = document.getElementById('deck');
const disc      = document.getElementById('disc');
const glyphs    = document.getElementById('glyphs');
const swDesc    = document.getElementById('swDesc');
const tranceNote= document.getElementById('tranceNote');
const drawBtn   = document.getElementById('drawBtn');
const endBtn    = document.getElementById('endBtn');
const resetBtn  = document.getElementById('resetBtn');
const chronoBtn = document.getElementById('chronoBtn');
const trickBtn  = document.getElementById('trickBtn');
const mCosts    = document.getElementById('mCosts');
const mRow      = document.getElementById('mRow');
const hand      = document.getElementById('hand');
const slots     = document.getElementById('slots');
const aiSlots   = document.getElementById('aiSlots');
const glyphView = document.getElementById('glyphView');
const turnTag   = document.getElementById('turnTag');

// Update the selected Spellweaver and reset trance state.
function setSpellweaver(name) {
  // Update current Spellweaver in state
  S.sw = name;
  // Update description in HUD
  swDesc.textContent = SPELLWEAVERS[name].desc;
  // Clear any previously activated trance thresholds
  S.tranceHit = {};
  // Apply trance abilities that match your current HP
  applyTranceIfEligible();
  // Re-render the UI to reflect the change
  render();
}
  
/* Core */
function reset(swName){
  const name = swName || document.getElementById('swSelect').value || Object.keys(SPELLWEAVERS)[0];
  S={
    sw:name,
    hp:5, ae:0, deck:makeDeck(), hand:[], disc:[], slots:[null,null,null], glyphs:[],
    ai:{hp:5, ae:0, deck:makeDeck(), hand:[], disc:[], slots:[null,null,null], glyphs:[], lastInstant:null, taxes:0, blockedSlots:[]},
    flowDeck: makeFlow(), flowRow:[null,null,null,null,null],
    flags:{ preventOnce:false, preventAvailable:false, glyphAether:false, hasChrono:false, copyInst:false, leftDiscount:false, freeChannelOnBuy:false, trickOnce:false, trickUsed:false, chronoUsed:false },
    lastInstant:null, turn:1,
    tranceHit:{}, taxes:0, blockedSlots:[], // player tax & block
  };
  for(let i=0;i<5;i++){ draw(); aiDraw(); }
  slideFlow(true);
  render();
  log(`New game — Spellweaver: ${S.sw}.`);
}

/* Draw / Play / Channel */
function draw(){
  if(!S.deck.length){ if(!S.disc.length){ log("No cards to draw."); return; } S.deck=shuf(S.disc); S.disc=[]; log("You reshuffle."); }
  S.hand.push(S.deck.pop()); render();
}
function channelSelf(handIdx){ // Channel Spark
  const c=S.hand.splice(handIdx,1)[0]; S.ae+=1; S.disc.push(c); log(`Channel Spark (+1⚡)`); render();
}
function channel(handIdx){ // generic channel other cards (their value)
  const c=S.hand.splice(handIdx,1)[0]; const gain=c.v||0; S.ae+=gain; S.disc.push(c); log(`Channel ${c.n} (+${gain}⚡)`); render();
}
function playFromHand(handIdx){
  const c=S.hand.splice(handIdx,1)[0];
  if(c.t==="Spell"){
    const s=S.slots.findIndex((x,i)=>!x && !S.blockedSlots.includes(i)); 
    if(s<0){ log("No available slot (or blocked)."); S.hand.push(c); render(); return; }
    // check ambush and bind triggers before placing
    if(triggerAmbush(S.ai)){ log("AI’s Ambush cancels your spell and deals 1."); damageYou(1); S.disc.push(c); render(); return; }
    if(triggerBind(S.ai, S, s)){
      // spell cancelled and slot blocked; discard card and return
      S.disc.push(c); render(); return;
    }
    S.slots[s]={c,ph:1,advUsed:false}; log(`You play ${c.n} to Slot ${s+1}.`);
  } else if(c.t==="Glyph"){
    S.glyphs.push(c); log("You set a Glyph face-down.");
  } else {
    runInstant("you", c);
    S.disc.push(c);
    if(S.flags.copyInst){ log("Instant Echo: your instant repeats."); runInstant("you", c); }
    S.lastInstant=c;
  }
  render();
}

/* Advance (no auto-tick; once/turn per spell) */
function advance(slotIdx){
  const s=S.slots[slotIdx]; if(!s) return;
  const tax = S.taxes||0;
  const cost = 1 + tax;
  if (s.advUsed) { log("That spell has already been advanced this turn."); return; }
  if (S.ae < cost) { log(`Need ${cost}⚡ to advance.`); return; }
  S.ae -= cost; s.ph += 1; s.advUsed = true;
  if (s.ph >= (s.c.p||99)) { resolvePlayer(slotIdx); }
  render();
}

/* Resolve + Effects */
function runInstant(who,c){
  switch(c.eff){
    case "spark": (who==="you")?damageAI(1):damageYou(1); break;
    case "shield": if(who==="you"){ S.flags.preventAvailable=true; log("Shield Flicker armed: prevent 1 this round."); } break;
    case "chan_self": if(who==="you"){ S.ae+=1; log("+1⚡ (Channel Spark)."); } break;
    case "accel":{
      if(who==="you"){
        const idx=S.slots.findIndex(s=>s && !s.advUsed); if(idx<0){ log("No eligible spell to accelerate."); break; }
        S.slots[idx].ph=Math.min(S.slots[idx].c.p, S.slots[idx].ph+1); S.slots[idx].advUsed=true;
        log("Accelerate: +1 phase."); if(S.slots[idx].ph===S.slots[idx].c.p){ resolvePlayer(idx); }
      } else {
        const ids=S.ai.slots.map((s,i)=>(s&&!s.advUsed)?i:-1).filter(i=>i>=0);
        if(ids.length){ const t=ids[0]; S.ai.slots[t].ph=Math.min(S.ai.slots[t].c.p, S.ai.slots[t].ph+1); S.ai.slots[t].advUsed=true; log("AI accelerates."); if(S.ai.slots[t].ph===S.ai.slots[t].c.p) aiResolve(t); }
      }
    } break;
    case "med":
      if(who==="you"){ S.ae+=1; draw(); log("Meditate: +1⚡ and draw 1."); }
      else { S.ai.ae+=1; aiDraw(); log("AI meditates."); }
      break;
    case "venom": (who==="you")?(damageAI(1),log("AI discards 1 (sim).")):(damageYou(1),log("You discard 1 (sim).")); break;
    case "counter": log((who==="you")?"Null Pulse readied.":"AI holds a counter."); break;
  }
}
function runResolve(who,c){
  switch(c.eff){
    case "hex_plus":
      if(who==="you"){
        if(consumeBarrier(S.ai)) break;
        log("Minor Hex+: AI discards 1 and loses 1⚡ (sim)."); S.ai.ae=Math.max(0,S.ai.ae-1);
      } else {
        if(consumeBarrier(S)) break;
        log("AI Hex+: you discard 1 and lose 1⚡ (sim)."); S.ae=Math.max(0,S.ae-1);
      }
      break;
    case "ember": (who==="you")?damageAI(2):damageYou(2); break;
    case "swap": log(who==="you"?"Phase Swap: swapped (abstract).":"AI swaps (no-op)." ); break;
    case "loop":
      if(who==="you"){ if(S.lastInstant){ log(`Temporal Loop replays ${S.lastInstant.n}.`); runInstant("you", S.lastInstant); } else { draw(); log("Loop draws 1 (no instant)."); } }
      break;
    case "tax":
      if(who==="you"){ S.ai.taxes = (S.ai.taxes||0)+1; log("Stonewall: AI’s next Advance +1⚡."); }
      else { S.taxes = (S.taxes||0)+1; log("AI Stonewall: your next Advance +1⚡."); }
      break;
    case "bargain":
      if(who==="you"){ damageAI(3); S.hp=Math.max(0,S.hp-2); log("Dark Bargain recoil: you lose 2♥."); }
      else { damageYou(3); S.ai.hp=Math.max(0,S.ai.hp-2); log("AI takes 2♥ recoil."); }
      break;
  }
}
function consumeBarrier(target){
  const bi=target.glyphs.findIndex(g=>g.eff==="g_barrier");
  if(bi>-1){ target.glyphs.splice(bi,1); log((target===S)?"Your Chrono Barrier negates it.":"AI’s Chrono Barrier negates it."); return true; }
  return false;
}

/* Damage + Trance */
function damageYou(n){
  // mirror
  const m=S.glyphs.findIndex(g=>g.eff==="g_mirror");
  if(m>-1 && n>0){ S.glyphs.splice(m,1); log("Your Mirror Ward reflects the damage!"); if(S.flags.glyphAether){ S.ae+=1; log("+1⚡ (glyph flip)."); } damageAI(n); return; }
  // barrier
  if(consumeBarrier(S)){ if(S.flags.glyphAether){ S.ae+=1; log("+1⚡ (glyph flip)."); } return; }
  let dmg=n;
  if(S.flags.preventAvailable){ dmg=Math.max(0,dmg-1); S.flags.preventAvailable=false; log("Ward prevents 1."); }
  if(dmg>0){ S.hp=Math.max(0,S.hp-dmg); log(`<span class="bad">You take ${dmg} damage.</span>`); applyTranceIfEligible(); }
}
function damageAI(n){
  const m=S.ai.glyphs.findIndex(g=>g.eff==="g_mirror");
  if(m>-1 && n>0){ S.ai.glyphs.splice(m,1); log("AI Mirror Ward reflects!"); damageYou(n); return; }
  if(consumeBarrier(S.ai)) return;
  S.ai.hp=Math.max(0,S.ai.hp-n); log(`<span class="good">AI takes ${n} damage.</span>`);
}
function applyTranceIfEligible(){
  const spec = SPELLWEAVERS[S.sw];
  let fired=[];
  spec.trance.forEach(step=>{
    if(S.hp<=step.hp && !S.tranceHit[step.hp]){
      step.apply(S); S.tranceHit[step.hp]=true;
      fired.push(`${step.hp}♥: ${step.label}`);
    }
  });
  if(fired.length){ log(`<b>Trance</b> — ${fired.join(" ")} <span class="badge">(${S.sw})</span>`); }
  if(S.flags.preventOnce) S.flags.preventAvailable=true;
  render();
}

/* Glyph hooks */
function triggerAmbush(owner){
  const i=owner.glyphs.findIndex(g=>g.eff==="g_ambush"); if(i>-1){ owner.glyphs.splice(i,1); return true; } return false;
}

/*
 * Seal of Binding hook.
 * When a spell is played into a slot, before placing it, call this function.
 * If the defending player (defender) has a g_bind glyph, the spell is cancelled
 * and the attacker’s slot is blocked until the defender’s next turn.
 * attacker.blockedSlots is an array of slot indices that may not be used.
 */
function triggerBind(defender, attacker, slotIdx){
  const idx = defender.glyphs.findIndex(g => g.eff === "g_bind");
  if (idx > -1) {
    // remove the glyph
    defender.glyphs.splice(idx, 1);
    // ensure blockedSlots exists
    if (!attacker.blockedSlots) attacker.blockedSlots = [];
    attacker.blockedSlots.push(slotIdx);
    // log appropriate message
    if (defender === S) {
      log(`Your Seal of Binding cancels the spell and blocks Slot ${slotIdx + 1} until your next turn.`);
    } else {
      log(`AI’s Seal of Binding cancels your spell and blocks its Slot ${slotIdx + 1} until its next turn.`);
    }
    return true;
  }
  return false;
}

/* Aetherflow: new costs 4/3/2/2/2; purchases -> discard (or set if Glyph) */
function flowCostAt(i){ const band=[4,3,2,2,2]; let cost=band[i]; if(i===0 && S.flags.leftDiscount) cost=Math.max(1,cost-1); return cost; }
function slideFlow(initial=false){ S.flowRow=[null, ...S.flowRow.slice(0,4)]; const next=S.flowDeck.pop(); S.flowRow[0]=next||null; if(!initial) render(); }
function buy(i){
  const card=S.flowRow[i]; if(!card){ log("Empty."); return; }
  const cost=flowCostAt(i); if(S.ae<cost){ log("Not enough ⚡."); return; }
  S.ae-=cost;
  if(card.t==="Glyph"){
    S.glyphs.push(card); log(`You learn ${card.n} and set it face-down.`);
  } else {
    S.disc.push(card); log(`You learn ${card.n}; it will shuffle into your deck.`);
  }
  S.flowRow[i]=null;
  if(S.flags.freeChannelOnBuy && S.hand.length>0){
    const c=S.hand.shift(); const g=c.v||1; S.ae+=g; S.disc.push(c); log(`Free channel on buy: ${c.n} (+${g}⚡).`);
  }
  render();
}

/* AI (respects new rules: no auto-tick; one advance/turn per spell) */
function aiDraw(){ if(!S.ai.deck.length){ if(S.ai.disc.length){ S.ai.deck=shuf(S.ai.disc); S.ai.disc=[]; log("AI reshuffles."); } else return; } S.ai.hand.push(S.ai.deck.pop()); }
function aiTryCounter(){ const idx=S.ai.hand.findIndex(c=>c.eff==="counter"); if(idx>-1 && Math.random()<0.45){ const c=S.ai.hand.splice(idx,1)[0]; S.ai.disc.push(c); return true; } return false; }
function playerTryCounter(){ const idx=S.hand.findIndex(c=>c.eff==="counter"); if(idx>-1){ const c=S.hand.splice(idx,1)[0]; S.disc.push(c); log("You use Null Pulse to counter!"); return true; } return false; }

function aiTurn(){
  log("— AI Turn —"); aiDraw();
  // Play a glyph sometimes
  const gIdx=S.ai.hand.findIndex(c=>c.t==="Glyph");
  if(gIdx>-1 && Math.random()<0.6){
    const g=S.ai.hand.splice(gIdx,1)[0];
    // AI sets any glyph face-down (including Seal of Binding). The blocking effect will be handled
    // by triggerBind when a spell is played into that slot.
    S.ai.glyphs.push(g);
    log("AI sets a Glyph.");
  }
  // Play a spell if space
  const empty=S.ai.slots.findIndex(x=>!x);
  if(empty>-1){
    let idx=S.ai.hand.findIndex(c=>c.t==="Spell" && c.n==="Emberbolt");
    if(idx===-1) idx=S.ai.hand.findIndex(c=>c.t==="Spell");
    if(idx>-1){
      const card=S.ai.hand.splice(idx,1)[0];
      // check ambush and bind triggers before placing
      if(triggerAmbush(S)){ log("Your Ambush cancels AI’s spell and deals 1."); damageAI(1); S.ai.disc.push(card); }
      else if(triggerBind(S, S.ai, empty)){
        // player's Seal of Binding cancels the AI spell
        S.ai.disc.push(card);
      }
      else {
        S.ai.slots[empty]={c:card,ph:1,advUsed:false}; log(`AI plays ${card.n}.`);
      }
    }
  }
  // Play instant sometimes
  const med=S.ai.hand.findIndex(c=>c.eff==="med");
  if(med>-1 && Math.random()<0.6){ const c=S.ai.hand.splice(med,1)[0]; runInstant("ai", c); S.ai.disc.push(c); }
  const sp=S.ai.hand.findIndex(c=>c.eff==="spark");
  if(sp>-1 && Math.random()<0.33){ const c=S.ai.hand.splice(sp,1)[0]; runInstant("ai", c); S.ai.disc.push(c); }
  // Advance exactly one spell
  const actIdx=S.ai.slots.findIndex(s=>s && !s.advUsed);
  if(actIdx>-1){
    const tax = S.ai.taxes||0;
    const cost = 1 + tax;
    if(S.ai.ae>=cost){ S.ai.ae-=cost; S.ai.slots[actIdx].ph+=1; S.ai.slots[actIdx].advUsed=true; if(tax>0){ S.ai.taxes=0; } log("AI advances a spell."); if(S.ai.slots[actIdx].ph>=S.ai.slots[actIdx].c.p){ aiResolve(actIdx); } }
  }
  // Buy
  for(let i=4;i>=0;i--){
    const c=S.flowRow[i]; const cost=flowCostAt(i);
    if(c && cost<=S.ai.ae){
      S.ai.ae-=cost;
      if(c.t==="Glyph"){
        // all glyphs, including Seal of Binding, are set face-down for AI
        S.ai.glyphs.push(c);
        log("AI learns a Glyph.");
      } else {
        S.ai.disc.push(c);
        log(`AI learns ${c.n}.`);
      }
      S.flowRow[i]=null;
      break;
    }
  }
  // Unblock player slots at end of AI turn
  S.blockedSlots=[];
  // reset AI per-turn flags
  S.ai.slots.forEach(s=>{ if(s) s.advUsed=false; });
  render(); log("AI ends turn.");
}
function aiAdvanceAll(){}
function aiResolve(i){
  const s=S.ai.slots[i]; if(!s) return;
  if(playerTryCounter()){ S.ai.disc.push(s.c); S.ai.slots[i]=null; return; }
  runResolve("ai", s.c);
  S.ai.disc.push(s.c); S.ai.slots[i]=null;
}

/* Turn flow (no auto tick) */
function endTurn(){
  // clear player tax once used? persist until you advance; not here
  // Unblock AI slots if you had bound them (done in AI turn), but we unbind player's block at AI turn end only
  S.ai.blockedSlots = [];
  // refresh once/turn ward
  if(S.flags.preventOnce) S.flags.preventAvailable=true;
  // reset per-turn adv flags
  S.slots.forEach(s=>{ if(s) s.advUsed=false; });
  slideFlow(); S.turn+=1; render(); log("You end your turn."); setTimeout(aiTurn, 360);
}

/* UI helpers */
function schoolFrameSVG(){
  return `<svg class="frameSvg" viewBox="0 0 100 140" preserveAspectRatio="none">
    <g fill="none" stroke-width="1.2">
      <path d="M3 18 L3 6 L18 6" /><path d="M82 6 L97 6 L97 18" />
      <path d="M3 122 L3 134 L18 134" /><path d="M82 134 L97 134 L97 122" />
      <circle cx="50" cy="10" r="3"/><circle cx="50" cy="130" r="3"/>
    </g>
  </svg>`;
}
function artSVG(school){
  if(school==="white") return `<svg viewBox="0 0 220 92"><g fill="none" stroke="#91b7ff" stroke-opacity=".6"><path d="M10,70 Q60,10 110,70 T210,70" /><circle cx="60" cy="40" r="10"/><circle cx="160" cy="34" r="8"/></g></svg>`;
  if(school==="gray")  return `<svg viewBox="0 0 220 92"><g fill="none" stroke="#b8bcc9" stroke-opacity=".55"><path d="M10,60 L210,60" /><path d="M50,20 L50,80" /><path d="M170,20 L170,80" /><circle cx="110" cy="46" r="16"/></g></svg>`;
  return `<svg viewBox="0 0 220 92"><g fill="none" stroke="#f0a6a6" stroke-opacity=".55"><path d="M10,76 Q110,10 210,76" /><path d="M110,20 L110,86" /><circle cx="110" cy="48" r="12"/></g></svg>`;
}
function tagRow(c){ const rar=c.rar?`<span class="rarity">${c.rar}</span>`:""; return `${rar}<span class="tag ${c.c}">${c.c.toUpperCase()}</span><span class="tag">${c.t}</span><span class="tag">Value ${c.v||0}</span>`; }

/* Render */
function render(){
  hp.textContent=S.hp; aiHp.textContent=S.ai.hp; ae.textContent=S.ae;
  deck.textContent=S.deck.length; disc.textContent=S.disc.length; glyphs.textContent=S.glyphs.length;
  turnTag.textContent=`Turn ${S.turn}`; swDesc.textContent=SPELLWEAVERS[S.sw].desc;
  tranceNote.textContent="Trance at "+SPELLWEAVERS[S.sw].trance.map(t=>t.hp+"♥").join(" & ");
  const swSel=document.getElementById('swSelect');
  if(!swSel.dataset.ready){
    Object.keys(SPELLWEAVERS).forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; swSel.appendChild(o); });
    swSel.dataset.ready="1"; swSel.value=S.sw; swSel.addEventListener('change', ()=> setSpellweaver(swSel.value));
  } else swSel.value=S.sw;

  // Market costs 4/3/2/2/2
  mCosts.innerHTML=""; [4,3,2,2,2].forEach((c,idx)=>{ let shown=c; if(idx===0 && S.flags.leftDiscount) shown=Math.max(1,c-1); const dv=document.createElement('div'); dv.className="cost"; dv.textContent=shown; mCosts.appendChild(dv); });
  // Market row
  mRow.innerHTML="";
  S.flowRow.forEach((c,idx)=>{
    const cell=document.createElement('div'); cell.className=`card ${c?c.c:''} ${c&&c.rar?'foil':''}`;
    if(!c){ cell.innerHTML=`<div class="name" style="opacity:.6">— empty —</div>`; mRow.appendChild(cell); return; }
    cell.innerHTML=`${schoolFrameSVG()}<div>${tagRow(c)}</div><div class="art ${c.c}">${artSVG(c.c)}</div><div class="name">${c.n}</div><div class="smallmuted">${c.txt}</div>`;
    const b=document.createElement('button'); b.textContent=`Learn (${flowCostAt(idx)}⚡)`; bindTap(b,()=>buy(idx));
    cell.appendChild(document.createElement('div')).className="cardActionsSpacer"; cell.appendChild(b); mRow.appendChild(cell);
  });
  // Hand fan
  const handEl=document.getElementById('hand'); handEl.innerHTML="";
  const N=S.hand.length, maxFan=Math.min(8,Math.max(3,N)), arcDeg=Math.min(60, 15*(N-1));
  for(let i=0;i<N;i++){
    const holder=document.createElement('div'); holder.className="hc"; holder.dataset.raise="0";
    const t=(N===1)?0:(i/(N-1)-0.5); const angle=t*arcDeg; const spread=(N>1)? (t*(N>5? 280:220)) : 0;
    holder.style.transform=`translate(calc(-50% + ${spread}px), 0px) rotate(${angle}deg)`;
    const c=S.hand[i]; const foil=c.rar?"foil":"";
    const card=document.createElement('div'); card.className=`card ${c.c} ${foil}`;
    card.innerHTML=`${schoolFrameSVG()}<div>${tagRow(c)}</div><div class="art ${c.c}">${artSVG(c.c)}</div><div class="name">${c.n}</div><div class="smallmuted">${c.txt}</div>`;
    const actions=document.createElement('div'); actions.className="hand-actions";
    const p=document.createElement('button'); p.textContent=(c.t==="Spell"?"Play to Slot":(c.t==="Glyph"?"Set Glyph":"Play"));
    bindTap(p,()=>playFromHand(i));
    const ch=document.createElement('button'); ch.textContent= c.eff==="chan_self" ? "Channel (+1)" : `Channel (+${c.v||0})`;
    bindTap(ch,()=> c.eff==="chan_self"?channelSelf(i):channel(i));
    actions.appendChild(p); actions.appendChild(ch); card.appendChild(actions); holder.appendChild(card);
    bindTap(card, ()=>{ holder.dataset.raise = holder.dataset.raise==="1" ? "0":"1"; });
    enableDrag(card, i, holder);
    handEl.appendChild(holder);
  }
  // Your slots
  slots.innerHTML="";
  S.slots.forEach((s,i)=>{
    const div=document.createElement('div'); div.className="slot"; div.dataset.slot=i;
    const blocked=S.blockedSlots.includes(i);
    if(s){
      const cc = s.c.c || ""; const foil = s.c.rar ? "foil" : "";
      div.innerHTML=`<div class="p">Slot ${i+1}${blocked?' — <b>BLOCKED</b>':''}</div>
        <div class="card ${cc} ${foil}" style="min-width:auto;max-width:none;padding:8px">
          ${schoolFrameSVG()}
          <div class="art ${cc}" style="height:68px">${artSVG(cc)}</div>
          <div class="name">${s.c.n}</div><div class="smallmuted">Phase ${s.ph}/${s.c.p}</div>
        </div>`;
      const b=document.createElement('button'); b.textContent=`Advance (1${S.taxes?`+${S.taxes}`:"")⚡)`;
      bindTap(b,()=>{ if(S.taxes>0){ S.taxes=0; } advance(i); });
      b.disabled = s.advUsed;
      div.appendChild(b);
    } else {
      div.innerHTML=`<div class="p">Slot ${i+1}${blocked?' — <b>BLOCKED</b>':''}</div><div class="small">Empty</div>`;
    }
    slots.appendChild(div);
  });
  // AI slots
  aiSlots.innerHTML="";
  S.ai.slots.forEach((s,i)=>{
    const div=document.createElement('div'); div.className="slot";
    const blocked=(S.ai.blockedSlots||[]).includes(i);
    if(s){
      const cc=s.c.c||""; const foil=s.c.rar?"foil":"";
      div.innerHTML=`<div class="p">Slot ${i+1}${blocked?' — <b>BLOCKED</b>':''}</div>
        <div class="card ${cc} ${foil}" style="min-width:auto;max-width:none;padding:8px">
          ${schoolFrameSVG()}
          <div class="art ${cc}" style="height:68px">${artSVG(cc)}</div>
          <div class="name">${s.c.n}</div><div class="smallmuted">Phase ${s.ph}/${s.c.p}</div>
        </div>`;
    } else {
      div.innerHTML=`<div class="p">Slot ${i+1}${blocked?' — <b>BLOCKED</b>':''}</div><div class="small">Empty</div>`;
    }
    aiSlots.appendChild(div);
  });
  // Glyphs
  glyphView.innerHTML="";
  if(S.glyphs.length){ for(let i=0;i<S.glyphs.length;i++){ const bar=document.createElement('div'); bar.className='glyphFace'; glyphView.appendChild(bar); } }
  else { glyphView.innerHTML=`<span class="small">No glyphs set.</span>`; }
  chronoBtn.disabled = !(S.flags.hasChrono);
  trickBtn.disabled  = !(S.flags.trickOnce && !S.flags.trickUsed);
}

/* Drag to slot (touch/mouse) — spells only */
function enableDrag(cardEl, handIdx, holder){
  let curX=0, curY=0, dragging=false;
  function onMove(e){
    const t = e.touches ? e.touches[0] : e;
    curX=t.clientX; curY=t.clientY;
    if(dragging){
      cardEl.style.position='fixed'; cardEl.style.left=(curX-90)+'px'; cardEl.style.top=(curY-120)+'px';
      cardEl.style.zIndex='9999';
      highlightHotSlot(curX,curY,true);
    }
  }
  function onStart(e){
    dragging=true; holder.dataset.raise="1"; cardEl.style.pointerEvents='none';
    document.addEventListener('touchmove', onMove, {passive:false});
    document.addEventListener('mousemove', onMove);
    document.addEventListener('touchend', onEnd, {passive:false});
    document.addEventListener('mouseup', onEnd);
  }
  function onEnd(){
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('touchend', onEnd);
    document.removeEventListener('mouseup', onEnd);
    cardEl.style.position=''; cardEl.style.left=''; cardEl.style.top=''; cardEl.style.pointerEvents=''; cardEl.style.zIndex='';
    const targetSlot = highlightHotSlot(curX,curY,false);
    if(targetSlot!=null){
      const c=S.hand[handIdx];
      if(c.t==="Spell"){
        if(S.blockedSlots.includes(targetSlot)){ log("That slot is blocked."); render(); return; }
        if(S.slots[targetSlot]){ log("That slot is occupied."); render(); return; }
        if(triggerAmbush(S.ai)){ log("AI’s Ambush cancels your spell and deals 1."); damageYou(1); S.disc.push(c); render(); return; }
        S.hand.splice(handIdx,1);
        S.slots[targetSlot]={c,ph:1,advUsed:false}; log(`You play ${c.n} to Slot ${targetSlot+1}.`);
        render();
        return;
      } else { log("Drag-to-slot is for Spells. Use the buttons for Instants and Glyphs."); }
    }
  }
  cardEl.addEventListener('touchstart', onStart, {passive:false});
  cardEl.addEventListener('mousedown', onStart);
}
function highlightHotSlot(x,y,apply){
  const els=[...document.querySelectorAll('#slots .slot')];
  let target=null;
  els.forEach((el,idx)=>{
    const r=el.getBoundingClientRect();
    const inside = x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
    if(apply){ el.classList.toggle('hot', inside && !S.slots[idx] && !S.blockedSlots.includes(idx)); }
    if(inside) target=idx;
  });
  if(!apply){ els.forEach(el=>el.classList.remove('hot')); }
  return target;
}

/* Buttons */
bindTap(drawBtn, ()=>draw());
bindTap(endBtn,  ()=>endTurn());
bindTap(resetBtn,()=>reset(S.sw));
bindTap(chronoBtn, ()=>{
  const i=S.slots.findIndex(s=>s && !s.advUsed); if(i<0){ log("No eligible spell."); return; }
  S.slots[i].ph=Math.min(S.slots[i].c.p, S.slots[i].ph+1); S.slots[i].advUsed=true; log("Chrono Step: +1 advance.");
  if(S.slots[i].ph===S.slots[i].c.p) resolvePlayer(i); render();
});
bindTap(trickBtn, ()=>{
  if(!S.flags.trickOnce || S.flags.trickUsed || !S.hand.length){ log("Gamble unavailable."); return; }
  const k=Math.floor(Math.random()*S.hand.length); const c=S.hand.splice(k,1)[0]; S.disc.push(c); draw(); S.flags.trickUsed=true; log("Gamble: random discard → draw 1."); render();
});

/* Init */
(function init(){
  const sel=document.getElementById('swSelect');
  Object.keys(SPELLWEAVERS).forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; sel.appendChild(o); });
  sel.addEventListener('change', ()=> setSpellweaver(sel.value));
  sel.value = Object.keys(SPELLWEAVERS)[0];
  swDesc.textContent = SPELLWEAVERS[sel.value].desc;
  reset(sel.value);
})();
</script>
</body>
</html>
