// boot-debug.js
console.log("[BRIDGE] Game + UI + Drag initialized and exposed to window.");

let st = null;
let dragLayer = null;
const DRAG_THRESHOLD = 6;
const DAMP = 0.25;

function initDragBridge() {
  dragLayer = document.querySelector('.drag-layer');
  if (!dragLayer) {
    dragLayer = document.createElement('div');
    dragLayer.className = 'drag-layer';
    document.body.appendChild(dragLayer);
  }

  document.addEventListener('pointerdown', onDown);
  document.addEventListener('pointermove', onMove);
  document.addEventListener('pointerup', onUp);
}

function onDown(e){
  if (isPreviewOpen()) return;
  const card = e.target.closest('.ribbon .card');
  if (!card || e.button !== 0) return;

  e.preventDefault();
  try { card.setPointerCapture(e.pointerId); } catch {}

  // Make press look like hover; freeze transitions.
  card.classList.add('is-pressing');
  card.classList.add('grab-intent');

  // Measure the *visual* position (DO NOT subtract transforms)
  const rect = card.getBoundingClientRect();
  const pageLeft = rect.left + window.scrollX;
  const pageTop  = rect.top  + window.scrollY;

  st = {
    pid: e.pointerId,
    card,
    startX: e.pageX,
    startY: e.pageY,
    // click point inside the card:
    offsetX: e.pageX - pageLeft,
    offsetY: e.pageY - pageTop,
    // current/target follow the visual position exactly:
    curX: pageLeft,
    curY: pageTop,
    targetX: pageLeft,
    targetY: pageTop,
    lastClientX: e.clientX,
    lastClientY: e.clientY,
    lifted: false,
    originParent: card.parentNode,
    originNext: card.nextSibling,
    placeholder: null,
    isInstant: card.classList.contains('is-instant'),
  };

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
  window.addEventListener('pointercancel', onUp);
  window.addEventListener('blur', onUp);
}


function lift(){
  if (!st || st.lifted) return;
  const { card, originParent, originNext } = st;

  // Measure again right before moving (still visual coords)
  const rect = card.getBoundingClientRect();
  const pageLeft = rect.left + window.scrollX;
  const pageTop  = rect.top  + window.scrollY;

  // Keep ribbon spacing with a placeholder
  const ph = document.createElement('div');
  ph.style.width = rect.width + 'px';
  ph.style.height = rect.height + 'px';
  ph.style.marginLeft = getComputedStyle(card).marginLeft;
  st.placeholder = ph;
  if (originNext) originParent.insertBefore(ph, originNext);
  else originParent.appendChild(ph);

  // Recompute grip offset from the *visual* top/left
  st.offsetX = st.startX - pageLeft;
  st.offsetY = st.startY - pageTop;

  // IMPORTANT: set CSS vars FIRST so there is no 0,0 frame
  card.style.setProperty('--drag-x', `${pageLeft}px`);
  card.style.setProperty('--drag-y', `${pageTop}px`);

  // Then switch classes and move the node
  card.classList.remove('grab-intent','is-pressing');
  card.classList.add('is-dragging');
  if (st.isInstant) card.classList.add('pulsing');

  dragLayer.appendChild(card);

  // Initialize state for the follow loop
  st.curX = pageLeft;
  st.curY = pageTop;
  st.targetX = pageLeft;
  st.targetY = pageTop;

  st.lifted = true;
  smoothFollow();
}


function onMove(e){
  if (isPreviewOpen()) { cancelDragNow(); return; }
  if (!st) return;

  st.lastClientX = e.clientX;
  st.lastClientY = e.clientY;

  const dx = e.pageX - st.startX;
  const dy = e.pageY - st.startY;

  if (!st.lifted && Math.hypot(dx, dy) > DRAG_THRESHOLD) lift();
  if (!st.lifted) return;

  // Follow cursor; keep the exact click point under the pointer
  st.targetX = e.pageX - st.offsetX;
  st.targetY = e.pageY - st.offsetY;
}


function onUp(e) {
  if (!st) return;
  const { card, originParent, placeholder } = st;

  card.classList.remove('is-dragging', 'grab-intent');
  if (placeholder && originParent) {
    originParent.insertBefore(card, placeholder);
    placeholder.remove();
  }
  card.style.removeProperty('--drag-x');
  card.style.removeProperty('--drag-y');

  st = null;
}

function smoothFollow() {
  if (!st || !st.lifted) return;
  const { card } = st;

  st.curX += (st.targetX - st.curX) * DAMP;
  st.curY += (st.targetY - st.curY) * DAMP;

  card.style.setProperty('--drag-x', `${st.curX}px`);
  card.style.setProperty('--drag-y', `${st.curY}px`);

  requestAnimationFrame(smoothFollow);
}

window.initDragBridge = initDragBridge;
window.addEventListener('DOMContentLoaded', initDragBridge);


/* ===== MTG-STYLE CARD EDGE + SHADOW (restores the look) ===== */

/* Base card: strong rounded edge, parchment face, layered shadows */
.card{
  position: relative;
  border-radius: 18px;
  background: linear-gradient(#fff, #faf8f4);   /* parchment */
  background-clip: padding-box;                 /* keep corners crisp */
  box-shadow:
    0 1px 0 rgba(255,255,255,.8) inset,         /* soft top bevel */
    0 0 0 1px #e9e2d7 inset,                    /* inner stroke (edge line) */
    0 10px 26px rgba(0,0,0,.12);                /* ambient drop */
}

/* Extra definition ring outside the card (very subtle “frame”) */
.card::before{
  content:"";
  position:absolute; inset:-1px;
  border-radius: 19px;                           /* outer ring follows radius */
  box-shadow: 0 0 0 1px rgba(0,0,0,.06);         /* faint outside line */
  pointer-events:none;
}

/* Optional soft vignette towards the edges (adds depth) */
.card::after{
  content:"";
  position:absolute; inset:0;
  border-radius: inherit;
  background: radial-gradient(ellipse at center,
              transparent 60%, rgba(0,0,0,.06) 100%);
  mix-blend-mode: multiply;
  pointer-events:none;
}

/* Hover lift keeps the rich shadow (NO filter: drop-shadow) */
.card:hover:not(.is-dragging){
  transform: translateY(-14px) scale(1.02);
  box-shadow:
    0 1px 0 rgba(255,255,255,.85) inset,
    0 0 0 1px #e9e2d7 inset,
    0 16px 36px rgba(0,0,0,.22);
  filter: none !important;
}

/* DRAGGING — keep the same rounded edge + shadows (no filter) */
.card.is-dragging{
  position: fixed;
  left: 0; top: 0;
  transform: translate3d(var(--drag-x,0px), var(--drag-y,0px), 0) scale(1.02);
  border-radius: 18px;
  background: linear-gradient(#fff,#faf8f4);
  background-clip: padding-box;
  /* identical shadow language while dragging */
  box-shadow:
    0 1px 0 rgba(255,255,255,.85) inset,
    0 0 0 1px #e9e2d7 inset,
    0 18px 40px rgba(0,0,0,.28);
  filter: none !important;
  cursor: grabbing;
  will-change: transform, box-shadow;
  transition: none !important;
}

/* Ensure hover can’t override drag visuals */
.card:hover.is-dragging{
  transform: translate3d(var(--drag-x,0px), var(--drag-y,0px), 0) scale(1.02) !important;
  box-shadow:
    0 1px 0 rgba(255,255,255,.85) inset,
    0 0 0 1px #e9e2d7 inset,
    0 18px 40px rgba(0,0,0,.28) !important;
  filter: none !important;
}

/* If you have “instant” pulsing, keep it but don’t kill the base shadow */
.card.is-instant.pulsing::after{
  /* your existing goldPulse still works; this preserves the base edge/shadow */
  mix-blend-mode: normal;
}


/* ===== ROLLBACK: restore MTG-style edge & shadow; remove vignette ===== */

/* 1) Kill the experimental vignette that washed the screen */
.card::after { content: none !important; }

/* 2) Reinstate the clean parchment face + crisp rounded edge */
.card,
.card.is-dragging{
  border-radius: 18px;
  background: linear-gradient(#fff, #faf8f4);
  background-clip: padding-box;           /* keep corners crisp */
}

/* 3) Subtle printed edge (inner stroke) */
.card::before{
  content:"";
  position:absolute; inset:0;
  border-radius:inherit;
  box-shadow: inset 0 0 0 1px #e9e2d7;   /* MTG-like edge line */
  pointer-events:none;
}

/* 4) Idle/hover shadows (no filter: drop-shadow) */
.card{
  box-shadow: 0 6px 20px rgba(0,0,0,.08);
}
.card:hover:not(.is-dragging){
  transform: translateY(-14px) scale(1.02);
  box-shadow: 0 10px 26px rgba(0,0,0,.12);
  filter: none !important;
}

/* 5) Dragging: same rounded edge + deeper lift (no filter) */
.card.is-dragging{
  position: fixed; left: 0; top: 0;
  transform: translate3d(var(--drag-x, 0px), var(--drag-y, 0px), 0) scale(1.02);
  box-shadow: 0 18px 40px rgba(0,0,0,.28);
  filter: none !important;
  cursor: grabbing;
  will-change: transform, box-shadow;
  transition: none !important;
}
.card:hover.is-dragging{
  transform: translate3d(var(--drag-x, 0px), var(--drag-y, 0px), 0) scale(1.02) !important;
  box-shadow: 0 18px 40px rgba(0,0,0,.28) !important;
  filter: none !important;
}
