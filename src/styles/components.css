// boot-debug.js
console.log("[BRIDGE] Game + UI + Drag initialized and exposed to window.");

let st = null;
let dragLayer = null;
const DRAG_THRESHOLD = 6;
const DAMP = 0.25;

function initDragBridge() {
  dragLayer = document.querySelector('.drag-layer');
  if (!dragLayer) {
    dragLayer = document.createElement('div');
    dragLayer.className = 'drag-layer';
    document.body.appendChild(dragLayer);
  }

  document.addEventListener('pointerdown', onDown);
  document.addEventListener('pointermove', onMove);
  document.addEventListener('pointerup', onUp);
}

function onDown(e){
  if (isPreviewOpen()) return;
  const card = e.target.closest('.ribbon .card');
  if (!card || e.button !== 0) return;

  e.preventDefault();
  try { card.setPointerCapture(e.pointerId); } catch {}

  // Make press look like hover; freeze transitions.
  card.classList.add('is-pressing');
  card.classList.add('grab-intent');

  // Measure the *visual* position (DO NOT subtract transforms)
  const rect = card.getBoundingClientRect();
  const pageLeft = rect.left + window.scrollX;
  const pageTop  = rect.top  + window.scrollY;

  st = {
    pid: e.pointerId,
    card,
    startX: e.pageX,
    startY: e.pageY,
    // click point inside the card:
    offsetX: e.pageX - pageLeft,
    offsetY: e.pageY - pageTop,
    // current/target follow the visual position exactly:
    curX: pageLeft,
    curY: pageTop,
    targetX: pageLeft,
    targetY: pageTop,
    lastClientX: e.clientX,
    lastClientY: e.clientY,
    lifted: false,
    originParent: card.parentNode,
    originNext: card.nextSibling,
    placeholder: null,
    isInstant: card.classList.contains('is-instant'),
  };

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
  window.addEventListener('pointercancel', onUp);
  window.addEventListener('blur', onUp);
}


function lift(){
  if (!st || st.lifted) return;
  const { card, originParent, originNext } = st;

  // Measure again right before moving (still visual coords)
  const rect = card.getBoundingClientRect();
  const pageLeft = rect.left + window.scrollX;
  const pageTop  = rect.top  + window.scrollY;

  // Keep ribbon spacing with a placeholder
  const ph = document.createElement('div');
  ph.style.width = rect.width + 'px';
  ph.style.height = rect.height + 'px';
  ph.style.marginLeft = getComputedStyle(card).marginLeft;
  st.placeholder = ph;
  if (originNext) originParent.insertBefore(ph, originNext);
  else originParent.appendChild(ph);

  // Recompute grip offset from the *visual* top/left
  st.offsetX = st.startX - pageLeft;
  st.offsetY = st.startY - pageTop;

  // IMPORTANT: set CSS vars FIRST so there is no 0,0 frame
  card.style.setProperty('--drag-x', `${pageLeft}px`);
  card.style.setProperty('--drag-y', `${pageTop}px`);

  // Then switch classes and move the node
  card.classList.remove('grab-intent','is-pressing');
  card.classList.add('is-dragging');
  if (st.isInstant) card.classList.add('pulsing');

  dragLayer.appendChild(card);

  // Initialize state for the follow loop
  st.curX = pageLeft;
  st.curY = pageTop;
  st.targetX = pageLeft;
  st.targetY = pageTop;

  st.lifted = true;
  smoothFollow();
}


function onMove(e){
  if (isPreviewOpen()) { cancelDragNow(); return; }
  if (!st) return;

  st.lastClientX = e.clientX;
  st.lastClientY = e.clientY;

  const dx = e.pageX - st.startX;
  const dy = e.pageY - st.startY;

  if (!st.lifted && Math.hypot(dx, dy) > DRAG_THRESHOLD) lift();
  if (!st.lifted) return;

  // Follow cursor; keep the exact click point under the pointer
  st.targetX = e.pageX - st.offsetX;
  st.targetY = e.pageY - st.offsetY;
}


function onUp(e) {
  if (!st) return;
  const { card, originParent, placeholder } = st;

  card.classList.remove('is-dragging', 'grab-intent');
  if (placeholder && originParent) {
    originParent.insertBefore(card, placeholder);
    placeholder.remove();
  }
  card.style.removeProperty('--drag-x');
  card.style.removeProperty('--drag-y');

  st = null;
}

function smoothFollow() {
  if (!st || !st.lifted) return;
  const { card } = st;

  st.curX += (st.targetX - st.curX) * DAMP;
  st.curY += (st.targetY - st.curY) * DAMP;

  card.style.setProperty('--drag-x', `${st.curX}px`);
  card.style.setProperty('--drag-y', `${st.curY}px`);

  requestAnimationFrame(smoothFollow);
}

window.initDragBridge = initDragBridge;
window.addEventListener('DOMContentLoaded', initDragBridge);
