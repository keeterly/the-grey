// boot-debug.js
console.log("[BRIDGE] Game + UI + Drag initialized and exposed to window.");

let st = null;
let dragLayer = null;
const DRAG_THRESHOLD = 6;
const DAMP = 0.25;

function initDragBridge() {
  dragLayer = document.querySelector('.drag-layer');
  if (!dragLayer) {
    dragLayer = document.createElement('div');
    dragLayer.className = 'drag-layer';
    document.body.appendChild(dragLayer);
  }

  document.addEventListener('pointerdown', onDown);
  document.addEventListener('pointermove', onMove);
  document.addEventListener('pointerup', onUp);
}

function onDown(e) {
  const card = e.target.closest('.card');
  if (!card || st) return;

  st = {
    card,
    startX: e.pageX,
    startY: e.pageY,
    curX: 0,
    curY: 0,
    targetX: 0,
    targetY: 0,
    offsetX: 0,
    offsetY: 0,
    lifted: false,
    originParent: card.parentElement,
    originNext: card.nextSibling
  };

  card.classList.add('grab-intent');
}

function lift() {
  if (!st || st.lifted) return;
  const card = st.card;
  const rect = card.getBoundingClientRect();

  // exact position on page before reparenting
  const pageX = rect.left + window.scrollX;
  const pageY = rect.top + window.scrollY;

  // placeholder to keep layout
  const ph = document.createElement('div');
  ph.style.width = rect.width + 'px';
  ph.style.height = rect.height + 'px';
  ph.style.marginLeft = getComputedStyle(card).marginLeft;
  st.placeholder = ph;

  if (st.originNext) st.originParent.insertBefore(ph, st.originNext);
  else st.originParent.appendChild(ph);

  // offset between pointer and top-left of card
  st.offsetX = st.startX - pageX;
  st.offsetY = st.startY - pageY;

  // lock transform BEFORE adding dragging class
  card.style.setProperty('--drag-x', `${pageX}px`);
  card.style.setProperty('--drag-y', `${pageY}px`);

  card.classList.remove('grab-intent', 'is-pressing');
  dragLayer.appendChild(card);

  // mark as dragging *after* variables are defined
  card.classList.add('is-dragging');

  st.curX = pageX;
  st.curY = pageY;
  st.targetX = pageX;
  st.targetY = pageY;

  st.lifted = true;
  requestAnimationFrame(smoothFollow);
}

function onMove(e) {
  if (!st) return;

  const dx = e.pageX - st.startX;
  const dy = e.pageY - st.startY;

  // pick-up threshold
  if (!st.lifted && Math.hypot(dx, dy) > DRAG_THRESHOLD) {
    lift();
  }
  if (!st.lifted) return;

  st.targetX = e.pageX - st.offsetX;
  st.targetY = e.pageY - st.offsetY;
}

function onUp(e) {
  if (!st) return;
  const { card, originParent, placeholder } = st;

  card.classList.remove('is-dragging', 'grab-intent');
  if (placeholder && originParent) {
    originParent.insertBefore(card, placeholder);
    placeholder.remove();
  }
  card.style.removeProperty('--drag-x');
  card.style.removeProperty('--drag-y');

  st = null;
}

function smoothFollow() {
  if (!st || !st.lifted) return;
  const { card } = st;

  st.curX += (st.targetX - st.curX) * DAMP;
  st.curY += (st.targetY - st.curY) * DAMP;

  card.style.setProperty('--drag-x', `${st.curX}px`);
  card.style.setProperty('--drag-y', `${st.curY}px`);

  requestAnimationFrame(smoothFollow);
}

window.initDragBridge = initDragBridge;
window.addEventListener('DOMContentLoaded', initDragBridge);
