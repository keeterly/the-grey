export const HAND_SIZE = 5; export const STARTING_VITALITY = 5; export const STARTING_AETHER = 0; export const MAX_SLOTS = 3; export const FLOW_COSTS=[4,3,2,2,2];
export const Weavers=[{id:'aria',name:'Aria, Runesurge Adept',thresholds:{stage1:4,stage2:2},portrait:'assets/weaver_aria.jpg'},{id:'morr',name:'Morr, Gravecurrent Binder',thresholds:{stage1:4,stage2:1},portrait:'assets/weaver_morr.jpg'}];
export const Cards={PulseOfTheGrey:()=>({id:'c:pulse',name:'Pulse of the Grey',type:'SPELL',cost:{aether:0},aetherValue:0,advance:{maxSteps:1,costPerStep:{aether:1}}}),WispformSurge:()=>({id:'c:wisp',name:'Wispform Surge',type:'SPELL',cost:{aether:0},aetherValue:0,advance:{maxSteps:1,costPerStep:{aether:1}}}),GreyfireBloom:()=>({id:'c:greyfire',name:'Greyfire Bloom',type:'SPELL',cost:{aether:1},aetherValue:0,advance:{maxSteps:1,costPerStep:{aether:1}}}),EchoingReservoir:()=>({id:'c:echo',name:'Echoing Reservoir',type:'SPELL',cost:{aether:0},aetherValue:2,advance:{maxSteps:1,costPerStep:{aether:2}}}),DormantCatalyst:()=>({id:'c:catalyst',name:'Dormant Catalyst',type:'SPELL',cost:{aether:0},aetherValue:1,advance:{maxSteps:1,costPerStep:{aether:1}}}),AshenFocus:()=>({id:'c:ashen',name:'Ashen Focus',type:'SPELL',cost:{aether:0},aetherValue:1,advance:{maxSteps:1,costPerStep:{aether:2}}}),SurgeOfAsh:()=>({id:'c:surgeAsh',name:'Surge of Ash',type:'INSTANT',cost:{aether:1},aetherValue:0}),VeilOfDust:()=>({id:'c:veil',name:'Veil of Dust',type:'INSTANT',cost:{aether:1},aetherValue:0}),GlyphRemnantLight:()=>({id:'c:glyphRemnant',name:'Glyph of Remnant Light',type:'GLYPH',cost:{aether:0},aetherValue:0}),GlyphReturningEcho:()=>({id:'c:glyphEcho',name:'Glyph of Returning Echo',type:'GLYPH',cost:{aether:0},aetherValue:0})};
export function buildStarterDeckExact10(){return[Cards.PulseOfTheGrey(),Cards.PulseOfTheGrey(),Cards.WispformSurge(),Cards.GreyfireBloom(),Cards.EchoingReservoir(),Cards.PulseOfTheGrey(),Cards.SurgeOfAsh(),Cards.VeilOfDust(),Cards.GlyphRemnantLight(),Cards.GlyphReturningEcho()];}
export const FlowCards=[{id:'f:surgeCinders',name:'Surge of Cinders',type:'INSTANT',cost:{aether:2},aetherValue:0},{id:'f:pulseFeedback',name:'Pulse Feedback',type:'INSTANT',cost:{aether:3},aetherValue:0},{id:'f:refractedWill',name:'Refracted Will',type:'INSTANT',cost:{aether:2},aetherValue:0},{id:'f:aetherImpel',name:'Aether Impel',type:'INSTANT',cost:{aether:4},aetherValue:0},{id:'f:cascadeInsight',name:'Cascade Insight',type:'INSTANT',cost:{aether:3},aetherValue:0},{id:'f:resonantChorus',name:'Resonant Chorus',type:'SPELL',cost:{aether:0},aetherValue:1,advance:{maxSteps:1,costPerStep:{aether:1}}},{id:'f:emberlinePulse',name:'Emberline Pulse',type:'SPELL',cost:{aether:1},aetherValue:0,advance:{maxSteps:1,costPerStep:{aether:1}}},{id:'f:fracturedMemory',name:'Fractured Memory',type:'SPELL',cost:{aether:0},aetherValue:0,advance:{maxSteps:2,costPerStep:{aether:1}}},{id:'f:obsidianVault',name:'Obsidian Vault',type:'SPELL',cost:{aether:0},aetherValue:1,advance:{maxSteps:1,costPerStep:{aether:2}}},{id:'f:mirrorCascade',name:'Mirror Cascade',type:'SPELL',cost:{aether:1},aetherValue:0,advance:{maxSteps:1,costPerStep:{aether:2}}},{id:'f:sanguineFlow',name:'Sanguine Flow',type:'SPELL',cost:{aether:2},aetherValue:0,advance:{maxSteps:1,costPerStep:{aether:1}}},{id:'f:glyphWithering',name:'Glyph of Withering Light',type:'GLYPH',cost:{aether:0},aetherValue:0},{id:'f:glyphVigilant',name:'Glyph of Vigilant Echo',type:'GLYPH',cost:{aether:0},aetherValue:0},{id:'f:glyphBuriedHeat',name:'Glyph of Buried Heat',type:'GLYPH',cost:{aether:0},aetherValue:0},{id:'f:glyphSoulglass',name:'Glyph of Soulglass',type:'GLYPH',cost:{aether:0},aetherValue:0}];
function mulberry32(seed){let t=seed>>>0;return()=>{t+=0x6D2B79F5;let r=Math.imul(t^(t>>>15),1|t);r^=r+Math.imul(r^(r>>>7),61|r);return((r^(r>>>14))>>>0)/4294967296;};}
function shuffle(a,rng){const c=a.slice();for(let i=c.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[c[i],c[j]]=[c[j],c[i]];}return c;}
function computeTranceStage(v,w){if(v<=w.thresholds.stage2)return 2;if(v<=w.thresholds.stage1)return 1;return 0;}
export function initState(opts={}){const rng=mulberry32(42);const mk=(w)=>({vitality:5,aether:0,channeled:0,deck:shuffle(buildStarterDeckExact10(),rng),hand:[],discard:[],slots:new Array(3).fill(0).map(()=>({card:null,progress:0,advancedThisTurn:false,isGlyph:false,glyphArmed:false})),weaver:Weavers.find(x=>x.id===w),tranceStage:0,perTurn:{}});const player=mk('aria');const ai=mk('morr');const flowDeck=shuffle(FlowCards.slice(),rng);const flowRow=flowDeck.splice(0,5);const s={rng,turn:1,activePlayer:'player',players:{player,ai},flowRow,flowDeck,flowTrash:[]};drawToHandSize(s,'player');drawToHandSize(s,'ai');['player','ai'].forEach(pid=>{const P=s.players[pid];P.tranceStage=computeTranceStage(P.vitality,P.weaver);});return s;}
function draw(s,p,n){const P=s.players[p];for(let i=0;i<n;i++){if(P.deck.length===0){if(P.discard.length===0)break;P.deck=shuffle(P.discard,s.rng);P.discard=[];}P.hand.push(P.deck.shift());}}
function drawToHandSize(s,p){const P=s.players[p];const need=Math.max(0,5-P.hand.length);draw(s,p,need);}
export function serializePublic(s){return{turn:s.turn,activePlayer:s.activePlayer,flow:s.flowRow.map((c,i)=>({id:c.id,name:c.name,type:c.type,price:[4,3,2,2,2][i]})),player:snapshot(s.players.player),ai:snapshot(s.players.ai)};}
function snapshot(P){return{vitality:P.vitality,aether:P.aether,channeled:P.channeled,deckCount:P.deck.length,hand:P.hand.map(c=>({id:c.id,name:c.name,type:c.type,aetherValue:c.aetherValue})),discardCount:P.discard.length,slots:P.slots.map(s=>({hasCard:!!s.card,card:s.card?{id:s.card.id,name:s.card.name,type:s.card.type}:null,progress:s.progress,isGlyph:s.isGlyph})),weaver:{id:P.weaver.id,name:P.weaver.name,stage:P.tranceStage,portrait:P.weaver.portrait||null}};}